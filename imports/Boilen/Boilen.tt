<#@ template language="C#" hostspecific="True" debug="True" #>
<#@ assembly name="PresentationCore" #>
<#@ assembly name="PresentationFramework" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xaml" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="WindowsBase" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.ComponentModel" #>
<#@ import namespace="System.Diagnostics.CodeAnalysis" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Threading" #>
<#@ import namespace="System.Windows" #>
<#@ import namespace="System.Windows.Controls" #>
<#@ import namespace="System.Windows.Media" #>
<#@ import namespace="System.Xml.Linq" #>
<# /* Boilen.tt -- Copyright © 2009 -- http://boilen.codeplex.com/ */ #>

// <auto-generated>
//   !!! WARNING !!!
//   !!!   This code was automatically generated from a T4 template.
//   !!!   Do not edit this file directly. Changes to this file will be lost.
//   !!! WARNING !!!
//   
//      Source Template - <#= System.IO.Path.GetFileName(Host.TemplateFile) #>
// </auto-generated>
<#+ // Accessibility.cs

    /// <summary>
    /// Specifies the kinds of member accessibility.
    /// </summary>
    public enum Accessibility {

        Public = 0,
        Protected,
        Internal,
        Private,

    }

#>
<#+ // AliasTypeAttribute.cs

    /// <summary>
    /// Marks a type alias defined in a template file.
    /// </summary>
    [AttributeUsage( AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Interface )]
    public sealed class AliasTypeAttribute : Attribute {

        /// <summary>
        /// The type being aliased.
        /// </summary>
        public Type Alias { get; private set; }


        /// <summary>
        /// Initializes a new <see cref="AliasTypeAttribute"/> instance.
        /// </summary>
        /// <param name="nmspace">The type being aliased.</param>
        public AliasTypeAttribute( Type alias ) {
            Ensure.NotNull( alias );

            this.Alias = alias;
        }

    }

#>
<#+ // Changed.cs

    /// <summary>
    /// Specifies the available property value change callbacks.
    /// </summary>
    public enum Changed {

        None = 0,
        Static,
        Virtual,
        Instance,
        Parameterless,

    }

#>
<#+ // Coerce.cs

    /// <summary>
    /// Specifies the pre-defined kinds of property value coercion.
    /// </summary>
    public enum Coerce {

        None = 0,
        Custom,
        NonNegative,

    }

#>
<#+ // CompilationSymbol.cs

    /// <summary>
    /// Represents a conditional compilation symbol for a member (i.e. "#if DEBUG").
    /// </summary>
    public struct CompilationSymbol : IEquatable<CompilationSymbol>, IComparable<CompilationSymbol> {

        /// <summary>Empty conditional compilation symbol.</summary>
        public static readonly CompilationSymbol None = new CompilationSymbol( );

        /// <summary>Conditional compilation symbol for Silverlight 3.0.</summary>
        public static CompilationSymbol Silverlight { get { return new CompilationSymbol( GlobalSettings.SilverlightSymbol, false ); } }

        /// <summary>Conditional compilation symbol for non-Silverlight 3.0.</summary>
        public static CompilationSymbol NotSilverlight { get { return new CompilationSymbol( GlobalSettings.SilverlightSymbol, true ); } }


        /// <summary>
        /// The conditional compilation symbol.
        /// </summary>
        public readonly string Symbol;

        /// <summary>
        /// A value indicating whether this is for the else condition of a symbol (i.e. "#if DEBUG ... #else ... #endif").
        /// </summary>
        public readonly bool IsElseCondition;

        /// <summary>
        /// Gets a value indicating whether the member should compiled conditionally.
        /// </summary>
        public bool IsUnconditional { get { return string.IsNullOrEmpty( this.Symbol ); } }

        /// <summary>
        /// Gets the equivalent stand-along compilation symbol, including negation for else conditions.
        /// </summary>
        public string ConditionalSymbol { get { return this.IsElseCondition ? "!" + this.Symbol : this.Symbol ?? ""; } }


        /// <summary>
        /// Initializes a new instance of the <see cref="CompilationSymbol"/> struct with the specified symbol and else-condition value.
        /// </summary>
        public CompilationSymbol( string symbol, bool elseCondition = false ) {
            this.Symbol = symbol;
            this.IsElseCondition = elseCondition && !string.IsNullOrEmpty( symbol );
        }


        /// <summary>
        /// Determines whether the specified <see cref="CompilationSymbol"/> is covered by the current symbol.
        /// </summary>
        /// <param name="target">The <see cref="CompilationSymbol"/> to compare.</param>
        /// <returns><see langword="true"/> if the current symbol has the same or greater scope than the target symbol; otherwise, <see langword="false"/>.</returns>
        public bool Covers( CompilationSymbol target ) {
            return this.IsUnconditional || this.Equals( target );
        }

        /// <summary>
        /// Returns a <see cref="CompilationSymbol"/> that covers both of the specified symbols.
        /// </summary>
        /// <param name="first">The first symbol to cover.</param>
        /// <param name="second">The second symbol to cover.</param>
        /// <returns>A <see cref="CompilationSymbol"/> covering both the <paramref name="first"/> and <paramref name="second"/> symbols.</returns>
        public static CompilationSymbol Combine( CompilationSymbol first, CompilationSymbol second ) {
            if( first.Covers( second ) )
                return first;
            else if( second.Covers( first ) )
                return second;
            else
                return CompilationSymbol.None;
        }

        /// <summary>
        /// Determines whether the specified <see cref="CompilationSymbol"/> is compatible with the current symbol.
        /// </summary>
        /// <param name="target">The <see cref="CompilationSymbol"/> to compare.</param>
        /// <returns><see langword="true"/> if the current symbol covers or is not contradicted by the target symbol; otherwise, <see langword="false"/>.</returns>
        public bool Compatible( CompilationSymbol target ) {
            return this.Covers( target )
                || target.IsUnconditional
                || (target.ConditionalSymbol.Contains( this.Symbol ) && !target.ConditionalSymbol.Contains( "!" + this.Symbol ));
        }

        /// <summary>
        /// Returns the simplest <see cref="CompilationSymbol"/> that covers both symbols.
        /// </summary>
        /// <param name="other">The other symbol to cover.</param>
        /// <returns>A <see cref="CompilationSymbol"/> including both the <paramref name="first"/> and <paramref name="second"/> symbols.</returns>
        public CompilationSymbol Append( CompilationSymbol other ) {
            CompilationSymbol appended;
            if( this.Covers( other ) )
                appended = other;
            else if( other.Covers( this ) )
                appended = this;
            else
                appended = new CompilationSymbol( this.ConditionalSymbol + " && " + other.ConditionalSymbol, false );

            return appended;
        }


        /// <inheritdoc/>
        public override string ToString( ) {
            if( this.IsUnconditional )
                return "";
            else if( this.IsElseCondition )
                return "#else // !" + this.Symbol;
            else
                return "#if " + this.Symbol;
        }

        /// <inheritdoc/>
        public override int GetHashCode( ) {
            return this.Symbol == null ? 0 : this.Symbol.GetHashCode( ) + this.IsElseCondition.GetHashCode( );
        }

        /// <inheritdoc/>
        public override bool Equals( object obj ) {
            if( obj is CompilationSymbol )
                return false;

            return this.Equals( (CompilationSymbol)obj );
        }

        /// <inheritdoc/>
        public bool Equals( CompilationSymbol other ) {
            return this.Symbol == other.Symbol
                && this.IsElseCondition == other.IsElseCondition;
        }

        /// <inheritdoc/>
        public int CompareTo( CompilationSymbol other ) {
            // For the same Symbol, sort !SYMBOL after SYMBOL.
            int compare = Comparer<string>.Default.Compare( this.Symbol, other.Symbol );
            if( compare == 0 ) {
                compare = this.IsElseCondition.CompareTo( other.IsElseCondition );
            }
            // Otherwise, compare ConditionalSymbol, sorting !CONDITION after CONDITION.
            else {
                compare = Comparer<string>.Default.Compare(
                    this.ConditionalSymbol.Replace( "!", "" ),
                    other.ConditionalSymbol.Replace( "!", "" ) );

                if( compare == 0 )
                    compare = Comparer<string>.Default.Compare(
                        this.ConditionalSymbol.Replace( "!", "ZZZ" ),
                        other.ConditionalSymbol.Replace( "!", "ZZZ" ) );
            }

            return compare;
        }

    }

#>
<#+ // GlobalSettings.cs

    /// <summary>
    /// Provides helper methods for constructing <see cref="PartialType"/> instances.
    /// </summary>
    public static class GlobalSettings {

        /// <summary>
        /// Gets or sets the symbol used to identify the Silverlight runtime.
        /// </summary>
        public static string SilverlightSymbol { get; set; }

        /// <summary>
        /// Gets or sets the sub-namespace containing the <see cref="Guard"/> implementation.
        /// </summary>
        public static string ValidationSubNamespace { get; set; }

        /// <summary>
        /// Gets or sets the sub-namespace containing the dependency property extensions implementation.
        /// </summary>
        public static string DependencyPropertySubNamespace { get; set; }

        /// <summary>
        /// Gets or sets the sub-namespace containing the freezable extensions implementation.
        /// </summary>
        public static string FreezableSubNamespace { get; set; }

        /// <summary>
        /// Gets or sets the namespace containing custom code analysis rules.
        /// </summary>
        public static string CodeAnalysisRuleNamespace { get; set; }

        /// <summary>
        /// Gets or sets the name of a custom code analysis rule for weak events.
        /// </summary>
        public static string WeakEventCodeAnalysisRule { get; set; }

        /// <summary>
        /// Gets or sets the path prefix for the external documentation xml file.
        /// </summary>
        public static string ExternalDocumentationPrefix { get; set; }

        static GlobalSettings( ) {
            SilverlightSymbol = "SL3_0";
            FreezableSubNamespace = DependencyPropertySubNamespace = ValidationSubNamespace = "Restricted";
        }

    }

#>
<#+ // Implementation.cs

    /// <summary>
    /// Specifies the kinds of member implementation.
    /// </summary>
    [Flags]
    public enum Implementation {

        None = 0,
        Auto = 1 << 0,
        Custom = 1 << 1,
        AutoAndCustom = Auto | Custom,

    }

#>
<#+ // Inheritance.cs

    /// <summary>
    /// Specifies the kinds of member inheritance.
    /// </summary>
    public enum Inheritance {

        None = 0,
        Virtual,
        Override,
        New,

    }

#>
<#+ // InsertionPoint.cs

    /// <summary>
    /// Specifies where the inserted text should be written.
    /// </summary>
    public enum InsertionPoint {

        Usings = 0,
        BeforeTypeDeclaration,
        AfterTypeDeclaration,
        Body,

    }

#>
<#+ // Partial.cs

    /// <summary>
    /// Provides helper methods for constructing <see cref="PartialType"/> instances.
    /// </summary>
    public static class Partial {

        /// <summary>
        /// Creates a new <see cref="PartialType"/> with the specified type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The <see cref="System.Type"/> to extend.</typeparam>
        public static PartialType Type<T>( ) { return Partial.Type( typeof( T ) ); }

        /// <summary>
        /// Creates a new <see cref="PartialType"/> with the specified <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The <see cref="System.Type"/> to extend.</param>
        public static PartialType Type( Type type ) { return new PartialType( type ); }

        /// <summary>
        /// Creates a new <see cref="PartialType"/> derived from type <typeparamref name="T"/> with the specified <paramref name="name"/>.
        /// </summary>
        /// <typeparam name="T">The <see cref="System.Type"/> to derive from.</typeparam>
        /// <param name="name">The name of the derived type to create.</param>
        public static PartialType Type<T>( string name ) { return Partial.Type( name, typeof( T ) ); }

        /// <summary>
        /// Creates a new <see cref="PartialType"/> derived from <paramref name="baseType"/> with the specified <paramref name="name"/>.
        /// </summary>
        /// <param name="name">The name of the derived type to create.</param>
        /// <param name="baseType">The <see cref="System.Type"/> to derive from.</param>
        public static PartialType Type( string name, Type baseType ) { return new PartialType( name, baseType ); }

        /// <summary>
        /// Creates a new <see cref="PartialType"/> with the specified type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The <see cref="System.Type"/> to extend.</typeparam>
        /// <param name="baseType">The <see cref="System.Type"/> to derive from.</param>
        public static PartialType Type<T>( Type baseType ) { return Partial.Type( typeof( T ), baseType ); }

        /// <summary>
        /// Creates a new <see cref="PartialType"/> with the specified <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The <see cref="System.Type"/> to extend.</param>
        /// <param name="baseType">The <see cref="System.Type"/> to derive from.</param>
        public static PartialType Type( Type type, Type baseType ) { return new PartialType( type, baseType ); }

        /// <summary>
        /// Creates a new <see cref="PartialType"/> with the specified type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The <see cref="System.Type"/> to extend.</typeparam>
        /// <param name="baseType">The <see cref="System.Type"/> to derive from.</param>
        /// <param name="baseType">The <see cref="System.Type"/> to derive from.</param>
        /// <param name="silverlightBaseTypeName">The full name of the <see cref="System.Type"/> to derive from in silverlight.</param>
        public static PartialType Type<T>( Type baseType, string silverlightBaseTypeName ) { return Partial.Type( typeof( T ), baseType, silverlightBaseTypeName ); }

        /// <summary>
        /// Creates a new <see cref="PartialType"/> with the specified <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The <see cref="System.Type"/> to extend.</param>
        /// <param name="baseType">The <see cref="System.Type"/> to derive from.</param>
        /// <param name="silverlightBaseTypeName">The full name of the <see cref="System.Type"/> to derive from in silverlight.</param>
        public static PartialType Type( Type type, Type baseType, string silverlightBaseTypeName ) { return new PartialType( type, baseType, silverlightBaseTypeName ); }

    }

#>
<#+ // TemplateTypeAttribute.cs

    /// <summary>
    /// Marks a type defined in a template file.
    /// </summary>
    [AttributeUsage( AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Interface )]
    public sealed class TemplateTypeAttribute : Attribute {

        /// <summary>
        /// The namespace of the attributed type.
        /// </summary>
        public string Namespace { get; set; }


        /// <summary>
        /// Initializes a new <see cref="TemplateTypeAttribute"/> instance.
        /// </summary>
        public TemplateTypeAttribute( )
            : this( "" ) { }

        /// <summary>
        /// Initializes a new <see cref="TemplateTypeAttribute"/> instance.
        /// </summary>
        /// <param name="nmspace">The namespace of the template type.</param>
        public TemplateTypeAttribute( string nmspace ) {
            this.Namespace = nmspace ?? "";
        }

    }

#>
<#+ // Validate.cs

    /// <summary>
    /// Specifies the pre-defined kinds of property value validation.
    /// </summary>
    public enum Validate {

        None = 0,
        Custom,
        Enum,
        NotNull,

    }

#>
<#+ // CodeWriter.cs

    public abstract class CodeWriter : ICodeWriter {

        private bool afterNewline_ = true;
        private readonly Stack<string> indents_ = new Stack<string>( );


        public IDisposable PushIndent( string indent ) {
            this.indents_.Push( indent );
            return new Indent( ( ) => this.indents_.Pop( ) );
        }

        public void Write( string value ) {
            this.WriteIndent( false );
            this.WriteCore( value );
        }

        public void Write( string format, params object[] args ) {
            string value = string.Format( format, args );
            this.Write( value );
        }

        public void WriteUnindented( string format, params object[] args ) {
            string prefix = this.afterNewline_ ? "" : Environment.NewLine;
            this.afterNewline_ = false;
            this.Write( prefix + format, args );
        }

        public void WriteLine( ) {
            this.WriteLineCore( "" );
            this.afterNewline_ = true;
        }

        public void WriteLine( string value ) {
            this.WriteIndent( true );
            this.WriteLineCore( value );
        }

        public void WriteLine( string format, params object[] args ) {
            string value = string.Format( format, args );
            this.WriteLine( value );
        }

        public void WriteLineUnindented( string format, params object[] args ) {
            this.WriteUnindented( format, args );
            this.WriteLine( );
        }


        protected abstract void WriteCore( string value );
        protected abstract void WriteLineCore( string value );


        private void WriteIndent( bool willBeAfterNewline ) {
            if( this.afterNewline_ )
                foreach( string indent in this.indents_.Reverse( ) )
                    this.WriteCore( indent );

            this.afterNewline_ = willBeAfterNewline;
        }


        private sealed class Indent : IDisposable {
            private readonly Action dispose_;
            public Indent( Action dispose ) { this.dispose_ = dispose; }
            public void Dispose( ) { this.dispose_( ); }
        }

    }

#>
<#+ // DependencyPropertyMetadata.cs

    /// <summary>
    /// Represents the metadata arguments for registering a dependency property.
    /// </summary>
    public sealed class DependencyPropertyMetadata {

        private readonly string[] MetadataTypeNames;
        private readonly List<string> metadataArguments_ = new List<string>( );

        private readonly bool silverlight_;
        private DependencyPropertyMetadataKind metadataKind_;


        /// <summary>
        /// Gets a value indicating whether the metadata arguments are for use on silverlight or WPF.
        /// </summary>
        public bool Silverlight { get { return this.silverlight_; } }

        /// <summary>
        /// Gets the kind of metadata required by the added metadata arguments.
        /// </summary>
        public DependencyPropertyMetadataKind MetadataKind { get { return this.metadataKind_; } }

        /// <summary>
        /// Gets or sets the extensions used by the dependency property initializer.
        /// </summary>
        public Extensions UsedExtensions { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether a single argument should be declared inline or indented.
        /// </summary>
        public bool InlineSingleArgument { get; set; }

        /// <summary>
        /// Gets or sets the name of the coercion handler for the dependency property.
        /// </summary>
        public string CoerceHandler { get; set; }

        /// <summary>
        /// Gets or sets the name of the changed handler for the dependency property.
        /// </summary>
        public string ChangedHandler { get; set; }

        /// <summary>
        /// Gets or sets the name of the validation handler for the dependency property.
        /// </summary>
        public string ValidationHandler { get; set; }


        /// <summary>
        /// Initializes a new <see cref="DependencyPropertyMetadata"/> instance.
        /// </summary>
        public DependencyPropertyMetadata( TypeRepository typeRepository, bool silverlight ) {
            this.silverlight_ = silverlight;

            this.metadataKind_ = DependencyPropertyMetadataKind.Base;

            this.MetadataTypeNames = new string[1 + (int)DependencyPropertyMetadataKind.Framework];
            this.MetadataTypeNames[(int)DependencyPropertyMetadataKind.Base] = typeRepository.GetTypeName( typeof( PropertyMetadata ) );
            this.MetadataTypeNames[(int)DependencyPropertyMetadataKind.UI] = typeRepository.GetTypeName( typeof( UIPropertyMetadata ) );
            this.MetadataTypeNames[(int)DependencyPropertyMetadataKind.Framework] = typeRepository.GetTypeName( typeof( FrameworkPropertyMetadata ) );
        }

        /// <summary>
        /// Adds the specified metadata argument, updating <see cref="MetadataKind"/> as necessary to accomodate the argument's required minimum.
        /// </summary>
        public void AddMetadataArgument( string argument, DependencyPropertyMetadataKind minimumMetadataKind ) {
            if( string.IsNullOrEmpty( argument ) )
                return;

            this.metadataArguments_.Add( argument );
            if( minimumMetadataKind > this.MetadataKind ) { this.metadataKind_ = minimumMetadataKind; }
        }

        /// <summary>
        /// Writes the "new MetadataKind" expression, specifying all of the added metadata arguments.
        /// </summary>
        public void Write( ICodeWriter writer ) {
            string metadataTypeName = this.MetadataTypeNames[(int)this.MetadataKind];
            writer.Write( "new {0}", metadataTypeName );

            using( Enclose.Parenthesis( writer ) ) {
                if( this.InlineSingleArgument && this.metadataArguments_.Count == 1 )
                    writer.Write( this.metadataArguments_.Single( ) );
                else
                    using( Enclose.NewLine( writer ) )
                    using( Enclose.Indent( writer ) ) {
                        Util.Iterate( this.metadataArguments_, ( i, last ) => writer.WriteLine( "," ), ( i, a ) => writer.Write( a ) );
                    }
            }

            string validateHandler = this.Silverlight ? null : this.ValidationHandler;
            if( validateHandler != null ) {
                writer.WriteLine( "," );
                writer.Write( validateHandler );
            }
        }

    }

#>
<#+ // DependencyPropertyMetadataKind.cs

    /// <summary>
    /// Represents the types of dependency property metadata; 
    /// either <see cref="PropertyMetadata"/>, <see cref="UIPropertyMetadata"/>, or <see cref="FrameworkPropertyMetadata"/>.
    /// </summary>
    public enum DependencyPropertyMetadataKind {

        Base = 0,
        UI,
        Framework,

    }

#>
<#+ // Enclose.cs

    /// <summary>
    /// Provides methods for automatically formatting and reverting blocks of output text.
    /// </summary>
    public static class Enclose {

        /// <summary>
        /// Encloses the output in a four-space indent.
        /// </summary>
        public static IDisposable Indent( ICodeWriter writer ) { return Enclose.Indent( writer, null ); }
        private static IDisposable Indent( ICodeWriter writer, IDisposable outer ) {
            return new EncloseWriter(
                NoAction,
                NoAction,
                outer,
                writer.PushIndent( "    " )
            );
        }

        /// <summary>
        /// Encloses the output in an indented scope block, created using a pair of curly braces ("{" and "}").
        /// </summary>
        public static IDisposable Braces( ICodeWriter writer ) {
            return Enclose.Indent(
                writer,
                new EncloseWriter(
                    ( ) => writer.WriteLine( "{" ),
                    ( ) => writer.WriteLine( "}" )
                )
            );
        }

        /// <summary>
        /// Encloses the output in a pair of parenthesis ("(" and ")").
        /// </summary>
        public static IDisposable Parenthesis( ICodeWriter writer ) {
            return new EncloseWriter(
                ( ) => writer.Write( "(" ),
                ( ) => writer.Write( ")" )
            );
        }

        /// <summary>
        /// Encloses the output in a pair of square brackets ("[" and "]").
        /// </summary>
        public static IDisposable Brackets( ICodeWriter writer ) {
            return new EncloseWriter(
                ( ) => writer.Write( "[" ),
                ( ) => writer.Write( "]" )
            );
        }

        /// <summary>
        /// Encloses the output between a pair of new lines.
        /// </summary>
        public static IDisposable NewLine( ICodeWriter writer ) {
            return new EncloseWriter(
                ( ) => writer.WriteLine( ),
                ( ) => writer.WriteLine( )
            );
        }

        /// <summary>
        /// Encloses the output between a pair of opening and closing text lines, with optional format arguments.
        /// </summary>
        public static IDisposable Format( ICodeWriter writer, string openFormat, string closeFormat, params object[] args ) {
            Ensure.NotNull( writer, openFormat, closeFormat, args );
            return new EncloseWriter(
                ( ) => writer.WriteLine( openFormat, args ),
                ( ) => writer.WriteLine( closeFormat, args )
            );
        }

        /// <summary>
        /// Encloses the output between a pair of open and close region declarations ("#region {name}" and "#endregion").
        /// </summary>
        public static IDisposable Region( ICodeWriter writer, string name ) {
            return new EncloseWriter(
                NoAction,
                NoAction,
                Enclose.Format( writer, "#region {0}", "#endregion", name ),
                Enclose.NewLine( writer )
            );
        }


        private static void NoAction( ) { }

        private sealed class EncloseWriter : IDisposable {
            private readonly IDisposable[] outer_;
            private readonly Action close_;

            public EncloseWriter( Action open, Action close, params IDisposable[] outer ) {
                Ensure.NotNull( open, close, outer );

                this.close_ = close;
                this.outer_ = outer;
                Array.Reverse( this.outer_ );

                open( );
            }

            public void Dispose( ) {
                this.close_( );

                foreach( var item in this.outer_ )
                    using( item ) { }
            }
        }

    }

#>
<#+ // Ensure.cs

    /// <summary>
    /// Ensures arguments are valid.
    /// </summary>
    static class Ensure {

        /// <summary>
        /// Ensures arguments are not null.
        /// </summary>
        /// <param name="args">The argument values to check.</param>
        public static void NotNull( params object[] args ) {
            if( args == null ) { throw new ArgumentNullException( "args" ); }
            if( args.Length == 0 ) { throw new ArgumentException( "args" ); }

            for( int i = 0; i < args.Length; ++i )
                if( args[i] == null )
                    throw new ArgumentNullException( "args[" + i + "]" );
        }

        /// <summary>
        /// Ensures string argument is not null or empty.
        /// </summary>
        /// <param name="value">The string value to check.</param>
        public static void NotNullOrEmpty( string value ) {
            Ensure.NotNull( value );
            if( value.Length == 0 )
                throw new ArgumentException( "String cannot be empty." );
        }

        /// <summary>
        /// Ensures collection argument is not null or empty.
        /// </summary>
        /// <param name="collection">The collection to check.</param>
        public static void NotNullOrEmpty<T>( IEnumerable<T> collection ) {
            Ensure.NotNull( collection );
            if( !collection.Any( ) )
                throw new ArgumentException( "Collection cannot be empty." );
        }

        /// <summary>
        /// Ensures the argument satisfies the specified condition.
        /// </summary>
        /// <param name="condition">The condition to check.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The error message to use if the <paramref name="condition"/> is <false/>.</param>
        /// <param name="args">The format arguments for <paramref name="message"/>.</param>
        public static void ArgSatisfies( bool condition, string argumentName, string message, params object[] args ) {
            if( !condition )
                throw new ArgumentException( string.Format( message, args ), argumentName );
        }

        /// <summary>
        /// Ensures the argument satisfies the specified condition.
        /// </summary>
        /// <typeparam name="T">The actual type of the implementer.</typeparam>
        /// <param name="propertyType">The type of the dependency property given to the implementer.</param>
        public static void ArgTypeMatches<T>( Type propertyType ) {
            var aliasType = Util.GetAttribute<AliasTypeAttribute>( typeof( T ) );
            Type expectedType = aliasType == null ? typeof( T ) : aliasType.Alias;
            Ensure.ArgSatisfies( propertyType == expectedType, "T", "Property type {0} does not match implementer type argument {1}.", propertyType, typeof( T ) );
        }


        /// <summary>
        /// Ensures the specified condition is satisfied.
        /// </summary>
        /// <param name="condition">The condition to check.</param>
        /// <param name="message">The error message to use if the <paramref name="condition"/> is <false/>.</param>
        /// <param name="args">The format arguments for <paramref name="message"/>.</param>
        public static void Satisfies( bool condition, string message, params object[] args ) {
            if( !condition )
                throw new InvalidOperationException( string.Format( message, args ) );
        }

    }

#>
<#+ // Extensions.cs

    /// <summary>
    /// Specifies the extension namespaces used by a member.
    /// </summary>
    [Flags]
    public enum Extensions {

        None = 0,
        Validation = 1 << 0,
        DependencyProperties = 1 << 1,
        Freezable = 1 << 2,

    }

#>
<#+ // ICodeWriter.cs

    /// <summary>
    /// Represents a code file writer.
    /// </summary>
    public interface ICodeWriter {

        /// <summary>
        /// Increases the indent level by the specified value.
        /// </summary>
        /// <param name="indent">The indent value.</param>
        IDisposable PushIndent( string indent );


        /// <summary>
        /// Writes a string value to a target.
        /// </summary>
        /// <param name="value">The value to write.</param>
        void Write( string value );

        /// <summary>
        /// Formats and writes a string value to a target.
        /// </summary>
        /// <param name="format">The format string.</param>
        /// <param name="args">The arguments to the format string.</param>
        void Write( string format, params object[] args );

        /// <summary>
        /// Formats and writes a string value to a target, without indent.
        /// </summary>
        /// <param name="format">The format string.</param>
        /// <param name="args">The arguments to the format string.</param>
        void WriteUnindented( string format, params object[] args );


        /// <summary>
        /// Writes a newline to a target.
        /// </summary>
        void WriteLine( );

        /// <summary>
        /// Writes a string value to a target followed by a newline.
        /// </summary>
        /// <param name="value">The value to write.</param>
        void WriteLine( string value );

        /// <summary>
        /// Formats and writes a string value to a target followed by a newline.
        /// </summary>
        /// <param name="format">The format string.</param>
        /// <param name="args">The arguments to the format string.</param>
        void WriteLine( string format, params object[] args );

        /// <summary>
        /// Formats and writes a string value to a target followed by a newline, without indent.
        /// </summary>
        /// <param name="format">The format string.</param>
        /// <param name="args">The arguments to the format string.</param>
        void WriteLineUnindented( string format, params object[] args );

    }

#>
<#+ // PartialType.CodeGeneration.cs

    public sealed partial class PartialType {

        /// <summary>
        /// Generates the code to the specified writer.
        /// </summary>
        public void Run( ICodeWriter writer ) {
            this.Run( writer, true );
        }

        /// <summary>
        /// Generates the code to the write method.
        /// </summary>
        public void Run( Action<string> write ) {
            Ensure.NotNull( write );

            var writer = new StringBuilderCodeWriter( );
            this.Run( writer, false );

            write( writer.ToString( ) );
        }


        private void Run( ICodeWriter writer, bool includeNewLine ) {
            Ensure.NotNull( writer );

            try {
                if( includeNewLine )
                    writer.WriteLine( );

                this.RunCore( writer );
            }
            catch( Exception e ) {
                writer.WriteLine( "ERROR" );
                writer.WriteLine( "// Code generation failed:" );
                foreach( string line in e.ToString( ).Split( new[] { Environment.NewLine }, StringSplitOptions.None ) )
                    writer.WriteLine( "//   " + line );

                throw;
            }
        }

        private void RunCore( ICodeWriter writer ) {
            // Prepare implementers for writing.
            for( int i = 0; i < this.Implementers.Count; ++i ) {
                var implementer = this.Implementers[i];
                implementer.Prepare( );
            }

            // Get the members and check if any use validation.
            var members = this.GetMembers( );
            Extensions usedExtensions = Util.GetUsedExtensions( members );
            if( this.IsFreezable )
                usedExtensions |= Extensions.Freezable;

            if( usedExtensions.HasFlag( Extensions.Validation ) )
                this.AddSubNamespace( GlobalSettings.ValidationSubNamespace );
            if( usedExtensions.HasFlag( Extensions.DependencyProperties ) )
                this.AddSubNamespace( GlobalSettings.DependencyPropertySubNamespace );
            if( usedExtensions.HasFlag( Extensions.Freezable ) )
                this.AddSubNamespace( GlobalSettings.FreezableSubNamespace );

            var ptm = new PartialTypeMembers( this, members );


            // Write "using _;" declarations.
            this.WriteUsingDeclarations( writer );

            // Write "namespace _" declaration.
            writer.WriteLine( "namespace {0}", this.Namespace );
            using( Enclose.Braces( writer ) ) {
                writer.WriteLine( );

                // Write "using BaseType = SilverlightBaseType;", if necessary.
                if( !string.IsNullOrEmpty( this.SilverlightBaseTypeName ) ) {
                    writer.WriteLineUnindented( "#if {0}", CompilationSymbol.Silverlight.Symbol );
                    writer.WriteLine( "using {0} = {1};", this.BaseTypeName, this.SilverlightBaseTypeName );
                    writer.WriteLineUnindented( "#endif" );
                    writer.WriteLine( );
                }

                // Write type attributes.
                WriteAttributes( writer, members );

                // Write partial type declaration and any implemented interfaces.
                WriteInsertion( writer, InsertionPoint.BeforeTypeDeclaration );
                writer.Write( "partial {0} {1}", this.Kind, this.TypeName );
                this.WriteInterfaceDeclarations( writer, members );
                WriteInsertion( writer, InsertionPoint.AfterTypeDeclaration );
                writer.WriteLine( );

                // Write members of each implementer.
                using( Enclose.Braces( writer ) ) {
                    WriteInsertion( writer, InsertionPoint.Body );
                    ptm.Write( writer );
                }

                writer.WriteLine( );
            }
        }

        private void WriteInsertion( ICodeWriter writer, InsertionPoint location ) {
            string insertion;
            if( this.insertedText_.TryGetValue( location, out insertion ) )
                writer.Write( insertion );
        }

        private void WriteUsingDeclarations( ICodeWriter writer ) {
            var usedNamespaces = this.TypeRepository.UsedNamespaces
                .Where( n => !this.Namespace.StartsWith( n ) )
                .OrderBy( n => n.Contains( '=' ) ? "Z" + n : n )
                // Promote "System" using declarations above others.
                .GroupBy( n => n.StartsWith( "System" ) )
                .OrderBy( g => g.Key ? 0 : 1 )
                .SelectMany( g => g );

            foreach( string nmspace in usedNamespaces )
                writer.WriteLine( "using {0};", nmspace );
            WriteInsertion( writer, InsertionPoint.Usings );

            writer.WriteLine( );
            writer.WriteLine( );
        }

        private static void WriteAttributes( ICodeWriter writer, IEnumerable<Member> members ) {
            var attributeMembers = members.OfType<AttributeMember>( ).ToArray( );
            if( attributeMembers.Any( ) ) {
                // Write type attributes.
                Member.WriteMembers( writer, attributeMembers );
            }
        }

        private void WriteInterfaceDeclarations( ICodeWriter writer, IEnumerable<Member> members ) {
            var inheritanceMembers = members.OfType<InheritanceMember>( ).ToArray( );
            if( this.IsDerivedType || inheritanceMembers.Any( ) ) {
                // Write base type, if any.
                bool hasUnconditionalInheritors = inheritanceMembers.Any( i => i.Condition.IsUnconditional );
                bool preceded = this.IsDerivedType || hasUnconditionalInheritors;
                if( preceded ) {
                    writer.Write( " :" );
                    if( this.IsDerivedType )
                        writer.Write( " " + this.BaseTypeName + (hasUnconditionalInheritors ? "," : "") );
                }

                // Write interface members, if any.
                Member.WriteConditionalMembers(
                    writer,
                    inheritanceMembers,
                    ( i, last ) => {
                        if( i >= 0 ) {
                            writer.Write( "," );
                            writer.WriteLine( );
                        }
                    },
                    ( groups, i ) => {
                        if( i > 0 || (i == 0 && !hasUnconditionalInheritors) )
                            writer.WriteLine( "    {0}", i > 0 || preceded ? "," : ":" );
                        else if( i == 0 )
                            writer.WriteLine( );
                    }
                );
            }
        }


        private sealed class PartialTypeMembers {
            private enum MemberId {
                Unsupported = -1,
                Field = 0,
                Initializer,
                Accessor,
                Method,
                Group,
                Count
            }

            private readonly PartialType Parent;
            private readonly List<Member>[] Lists;


            public PartialTypeMembers( PartialType parent, IEnumerable<Member> members ) {
                // Create lists for each top-level member type.
                this.Parent = parent;
                this.Lists = Enumerable.Range( 0, (int)MemberId.Count ).Select( _ => new List<Member>( ) ).ToArray( );
                this.PopulateLists( members );
            }


            public void Write( ICodeWriter writer ) {
                bool listWritten = false;

                writer.WriteLine( );
                foreach( var list in this.Lists ) {
                    if( list.Any( ) ) {
                        if( listWritten ) {
                            writer.WriteLine( );
                            writer.WriteLine( );
                        }
                        else {
                            listWritten = true;
                        }

                        Member.WriteMembers( writer, list );
                    }
                }
                writer.WriteLine( );
            }


            private void PopulateLists( IEnumerable<Member> members ) {
                // Separate members into top-level types.
                var initType = new List<InitializationMember>( );
                var initFromParam = new List<InitializationMember>( );
                var initFromValue = new List<InitializationMember>( );
                var initTemplate = new List<InitializationMember>( );
                foreach( Member member in members ) {
                    MemberId id = GetMemberId( member );
                    if( id == MemberId.Unsupported )
                        continue;

                    // Initializer members will be placed in constructors or initializer methods.
                    if( id == MemberId.Initializer ) {
                        var initializer = (InitializationMember)member;
                        var initCollection = initializer.IsInstance
                            ? (initializer.IsParameterValue ? initFromParam : initFromValue)
                            : (initializer.IsOnApplyTemplate ? initTemplate : initType);
                        initCollection.Add( initializer );
                    }
                    // All other top-level members will be written directly.
                    else {
                        this.Lists[(int)id].Add( member );
                    }
                }


                // Create constructors and methods for initializers.
                var initializers = this.Lists[(int)MemberId.Initializer];
                var helpers = new List<Member>( );

                // Static type constructor.
                if( initType.Any( ) ) {
                    var staticConstructorBody = new BlockMember( ".cctor", w => {
                        Member.WriteMembers( w, initType );

                        w.WriteLine( );
                        w.WriteLine( this.Parent.TypeNamePrefix + ".InitializeType();" );
                    } );
                    var staticConstructor = new MethodMember( this.Parent.SimpleTypeName, "", staticConstructorBody ) { Modifiers = "static" };
                    staticConstructor.AddAttributes( this.Parent.cctorAttributes_ );

                    if( this.Parent.Type.IsClass )
                        staticConstructor.Attributes.Add( AttributeMember.SuppressMessage(
                            "Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline", "AUTOGEN: Initializes static members."
                        ) );

                    initializers.Add( staticConstructor );
                    helpers.Add( new MethodMember( "InitializeType", "void", null ) { Modifiers = "static" } );
                }

                // Instance constructors.
                if( initFromParam.Any( ) || initFromValue.Any( ) ) {
                    string constructorModifiers = Util.Lowercase( this.Parent.ConstructorAccessibility.ToString( ) );

                    ParameterMember[] baseInitFromParam = new ParameterMember[0];
                    var baseConstructorParameters = this.Parent.BaseType.GetConstructors( BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance ).OrderByDescending( c => c.GetParameters( ).Length );
                    if( baseConstructorParameters.Any( ) )
                        baseInitFromParam = MethodMember.GetParameters( baseConstructorParameters.First( ), this.CreateParameter ).ToArray( );

                    var initOnlyFromValue = FilterInitializers( initFromValue, initFromParam );
                    var initOnlyFromParam = FilterInitializers( initFromParam, initFromValue );
                    bool writeFullConstructor = initFromParam.Any( ) || baseInitFromParam.Any( ) || (initFromValue.Any( ) && this.Parent.Type.IsClass);
                    bool writeMinimalConstructor = initOnlyFromParam.Length != initFromParam.Count && (this.Parent.Type.IsClass || initOnlyFromParam.Any( ));

                    // Fully-parameterized instance constructor.
                    Doc docDependency = null;
                    if( writeFullConstructor ) {
                        string baseArguments = Util.Join( baseInitFromParam, ", ", ( i, baseParam ) => baseParam.Name );
                        string name = baseInitFromParam.Any( )
                            ? "    : base(" + baseArguments + ")"
                            : ".ctor";

                        var fullConstructorBody = new BlockMember( name, w => {
                            if( initFromParam.Any( ) ) {
                                Member.WriteMembers( w, initFromParam );

                                if( initOnlyFromValue.Any( ) )
                                    w.WriteLine( );
                            }

                            if( initOnlyFromValue.Any( ) )
                                Member.WriteMembers( w, initOnlyFromValue );

                            w.WriteLine( );
                            w.WriteLine( "this.InitializeInstance();" );
                        } ) { WriteName = baseInitFromParam.Any( ) };
                        var fullConstructor = new MethodMember( this.Parent.SimpleTypeName, "", fullConstructorBody ) { Modifiers = constructorModifiers };
                        var orderedParameters = initOnlyFromParam.Concat( initFromParam.Except( initOnlyFromParam ) );
                        this.AddParameters( fullConstructor, true, baseInitFromParam, orderedParameters );
                        fullConstructor.AddAttributes( this.Parent.ctorAttributes_ );
                        docDependency = fullConstructor.Doc;

                        initializers.Add( fullConstructor );
                        helpers.Add( new MethodMember( "InitializeInstance", "void", null ) );
                    }

                    // Minimally-parameterized default value constructor.
                    if( writeMinimalConstructor ) {
                        var minimalInitFromValue = FilterInitializers( initFromValue, initOnlyFromValue );
                        string baseArguments = Util.Join( baseInitFromParam, ", ", ( i, baseParam ) => baseParam.Name );
                        string minArguments = Util.Join( initOnlyFromParam.Concat( minimalInitFromValue ), ", ", ( i, init ) => init.Value );
                        string arguments = baseArguments + (baseArguments.Length > 0 && minArguments.Length > 0 ? ", " : "") + minArguments;
                        string name = "    : this(" + arguments + ")";

                        var minimalConstructorBody = new BlockMember( name, "" ) { WriteName = true };
                        var minimalConstructor = new MethodMember( this.Parent.SimpleTypeName, "", minimalConstructorBody ) { Modifiers = constructorModifiers };
                        this.AddParameters( minimalConstructor, false, baseInitFromParam, initOnlyFromParam );
                        minimalConstructor.DocDependencies.Add( docDependency );
                        initializers.Add( minimalConstructor );
                    }
                }

                // OnApplyTemplate initializer method.
                if( initTemplate.Any( ) ) {
                    const string OnApplyTemplate = "OnApplyTemplate";
                    const string InitializeTemplateParts = "InitializeTemplateParts";

                    var onApplyTemplateBody = new BlockMember( OnApplyTemplate, w => {
                        w.WriteLine( "base.{0}();", OnApplyTemplate );
                        w.WriteLine( );

                        Member.WriteMembers( w, initTemplate, ( i, last ) => w.WriteLine( ) );

                        w.WriteLine( );
                        w.WriteLine( "this.{0}();", InitializeTemplateParts );
                    } );
                    var onApplyTemplate = new MethodMember( OnApplyTemplate, "void", onApplyTemplateBody ) {
                        Doc = new Doc( this.Parent.DocTypeName, this.Parent.TypeName, this.Parent.DocTypeName, null ) {
                            InheritFrom = "System.Windows.FrameworkElement.OnApplyTemplate"
                        },
                        Modifiers = "public override"
                    };

                    initializers.Add( onApplyTemplate );
                    var onApplyTemplateHelper = new MethodMember( InitializeTemplateParts, "void", null );
                    helpers.Add( onApplyTemplateHelper );
                }

                initializers.AddRange( helpers );
            }


            private ParameterMember CreateParameter( string name, Type type, string description ) {
                string typeName = this.Parent.TypeRepository.GetTypeName( type );
                return new ParameterMember( name, typeName );
            }

            private static InitializationMember[] FilterInitializers( IEnumerable<InitializationMember> source, IEnumerable<InitializationMember> exclude ) {
                return source
                    .Where( sourceItem => !exclude.Any( excludedItem => sourceItem.Name == excludedItem.Name ) )
                    .ToArray( );
            }

            private void AddParameters( MethodMember constructor, bool isFullConstructor, IEnumerable<ParameterMember> baseParameters, IEnumerable<InitializationMember> parameters ) {
                const string Summary = "Initializes a new instance of the %see:type% {0}{1}.";
                string parameterNames = Util.Join(
                    baseParameters.Select( p => p.Name ).Concat( parameters.Select( p => p.Value ) ),
                    ( i, last ) => last ? i == 1 ? " and " : ", and " : ", ",
                    ( i, p ) => (i == 0 ? " with the specified " : "") + p
                );

                string name = this.Parent.TypeName;
                string type = this.Parent.DocTypeName;
                string fullyQualifiedName = this.Parent.SimpleTypeName + "(" + Util.Join( baseParameters.Select( p => Doc.GetDocTypeName( p.Type, null ) ).Concat( parameters.Select( p => Doc.GetDocTypeName( p.Type, null ) ) ), "," ) + ")";
                constructor.Doc = new Doc( fullyQualifiedName, name, type, null )
                    .AddSummary( Summary, this.Parent.Type.IsClass ? "class" : "struct", parameterNames );

                if( baseParameters.Any( ) ) {
                    if( GlobalSettings.ExternalDocumentationPrefix != null && !this.Parent.IsInternal )
                        constructor.Doc.UseIncludeTag( );
                    else
                        constructor.Doc.InheritFrom = "";

                    foreach( var baseParameter in baseParameters )
                        constructor.Parameters.Add( baseParameter );
                }

                foreach( var parameter in parameters ) {
                    constructor.Parameters.Add( new ParameterMember( parameter.Value, parameter.Type ) { Doc = parameter.Doc } );

                    constructor.Doc.AddExceptions( parameter.Guards );
                    if( isFullConstructor )
                        constructor.Body.AddGuards( parameter.Guards );
                }
            }

            private static MemberId GetMemberId( Member member ) {
                if( member is FieldMember )
                    return MemberId.Field;
                if( member is InitializationMember )
                    return MemberId.Initializer;
                if( member is AccessorMember )
                    return MemberId.Accessor;
                if( member is MethodMember )
                    return MemberId.Method;
                if( member is MemberGroup )
                    return MemberId.Group;
                if( member is AttributeMember || member is InheritanceMember )
                    return MemberId.Unsupported;

                throw new InvalidOperationException( "Unexpected member: " + member );
            }
        }

    }

#>
<#+ // PartialType.cs

    /// <summary>
    /// Represents a partial definition of a type.
    /// </summary>
    public sealed partial class PartialType {

        private readonly Dictionary<InsertionPoint, string> insertedText_ = new Dictionary<InsertionPoint, string>( );
        private readonly List<AttributeMember> cctorAttributes_ = new List<AttributeMember>( );
        private readonly List<AttributeMember> ctorAttributes_ = new List<AttributeMember>( );
        private readonly List<IImplementer> implementers_ = new List<IImplementer>( );
        private readonly TypeRepository typeRepository_ = new TypeRepository( );
        private readonly string kind_;

        private readonly Type type_;
        private readonly string typeName_;
        private readonly string typeFullName_;
        private readonly string typeNamespace_;
        private readonly string simpleTypeName_;
        private readonly string docTypeName_;
        private readonly bool useFullNamePrefix_;

        private readonly bool isDerivedType_;
        private readonly Type baseType_;
        private readonly string baseTypeName_;
        private readonly string silverlightBaseTypeName_;


        /// <summary>
        /// Gets the repository of types referenced by this 
        /// </summary>
        public TypeRepository TypeRepository { get { return this.typeRepository_; } }

        /// <summary>
        /// Gets the type to generate code for.
        /// </summary>
        public Type Type { get { return this.type_; } }

        /// <summary>
        /// Gets the name of the generator's type.
        /// </summary>
        public string TypeName { get { return this.typeName_; } }

        /// <summary>
        /// Gets the full name of the generator's type.
        /// </summary>
        public string TypeFullName { get { return this.typeFullName_; } }

        /// <summary>
        /// Gets a string that can be used to prefix members of the generator's type.
        /// </summary>
        public string TypeNamePrefix { get { return this.useFullNamePrefix_ ? this.TypeFullName : this.TypeName; } }

        /// <summary>
        /// Gets the simple name of the generator's type.
        /// </summary>
        public string SimpleTypeName { get { return this.simpleTypeName_; } }

        /// <summary>
        /// Gets the name of the generator's type that can be used in documentation references.
        /// </summary>
        public string DocTypeName { get { return this.docTypeName_; } }

        /// <summary>
        /// Gets the namespace of the generator's type.
        /// </summary>
        public string Namespace { get { return this.typeNamespace_; } }

        /// <summary>
        /// Gets a value indicating whether the type is in an internal namespace.
        /// </summary>
        public bool IsInternal { get { return this.typeNamespace_.EndsWith( ".Internal" ); } }

        /// <summary>
        /// Gets the kind of the generator's type (either "class" or "struct").
        /// </summary>
        public string Kind { get { return this.kind_; } }

        /// <summary>
        /// Gets a value indicating whether the type is derived from an explicit base type.
        /// </summary>
        public bool IsDerivedType { get { return this.isDerivedType_; } }

        /// <summary>
        /// Gets the type to declare as the generator's base type.
        /// </summary>
        public Type BaseType { get { return this.baseType_; } }

        /// <summary>
        /// Gets the name of the type to declare as the generator's base type.
        /// </summary>
        public string BaseTypeName { get { return this.baseTypeName_; } }

        /// <summary>
        /// Gets the name of the type to declare as the generator's base type in silverlight.
        /// </summary>
        public string SilverlightBaseTypeName { get { return this.silverlightBaseTypeName_; } }

        /// <summary>
        /// Gets or sets whether the <see cref="FrameworkElement.DefaultStyleKey"/> property can be overridden on WPF types.
        /// </summary>
        public bool IsStyleable { get { return TestType( typeof( FrameworkElement ) ) || TestType( typeof( FrameworkContentElement ) ); } }

        /// <summary>
        /// Gets or sets whether the type derives from <see cref="Freezable"/>.
        /// </summary>
        public bool IsFreezable { get { return TestType( typeof( Freezable ) ); } }

        /// <summary>
        /// Gets a value indicating whether the type is sealed.
        /// </summary>
        public bool IsSealed { get; set; }

        /// <summary>
        /// Gets or sets the accessibility of any instance constructors.
        /// </summary>
        public Accessibility ConstructorAccessibility { get; set; }

        /// <summary>
        /// Gets or sets whether to override the <see cref="FrameworkElement.DefaultStyleKey"/> property on WPF types.
        /// </summary>
        public bool OverrideDefaultStyleKey { get; set; }


        /// <summary>
        /// Gets the list of implementers that will be generated.
        /// </summary>
        public IList<IImplementer> Implementers { get { return this.implementers_; } }


        private PartialType( string derivedTypeName, Type type, Type baseType, string silverlightBaseTypeName ) {
            Ensure.NotNull( type );
            Ensure.Satisfies( type.IsClass || type.IsValueType, "Can only generate code for class and struct types." );

            this.type_ = type;
            this.kind_ = type.IsClass ? "class" : "struct";
            this.isDerivedType_ = baseType != null;

            if( !string.IsNullOrEmpty( derivedTypeName ) ) {
                this.typeName_ = derivedTypeName;
                int index = derivedTypeName.IndexOf( '<' );
                if( index > 0 )
                    derivedTypeName = derivedTypeName.Substring( 0, index );
                this.simpleTypeName_ = derivedTypeName;
            }
            else {
                this.typeName_ = this.TypeRepository.GetTypeName( type );
                this.simpleTypeName_ = this.TypeRepository.GetSimpleTypeName( type );
            }
            this.typeNamespace_ = this.TypeRepository.GetTypeNamespace( type );
            this.typeFullName_ = this.typeNamespace_ + "." + this.typeName_;
            this.docTypeName_ = Doc.GetDocTypeName( this.typeName_ );

            this.baseType_ = baseType ?? type.BaseType;
            this.baseTypeName_ = this.TypeRepository.GetTypeName( this.baseType_ );
            this.silverlightBaseTypeName_ = silverlightBaseTypeName
                ?? (this.baseType_ == typeof( Freezable ) ? this.TypeRepository.GetTypeName( typeof( DependencyObject ) ) : null)
                ?? (this.baseType_ == typeof( FrameworkContentElement ) ? this.TypeRepository.GetTypeName( typeof( FrameworkElement ) ) : null)
                ;

            this.IsSealed = this.Type.IsSealed;
            this.ConstructorAccessibility = this.Type.IsAbstract ? Accessibility.Protected : Accessibility.Public;
            this.OverrideDefaultStyleKey = !this.Type.IsAbstract && !typeof( Panel ).IsAssignableFrom( this.Type );
            this.useFullNamePrefix_ = this.Type.GetProperty( this.TypeName ) != null;

            if( this.IsFreezable ) {
                bool baseImplementsIFreezable = this.BaseType != typeof( Freezable );
                this.Implementers.Add( new FreezableImplementer( this ) { DeclareMembers = !baseImplementsIFreezable } );
            }
        }

        /// <summary>
        /// Initializes a new <see cref="PartialType"/> instance.
        /// </summary>
        /// <param name="type">The type to generate code for.</param>
        public PartialType( Type type )
            : this( null, type, null, null ) { }

        /// <summary>
        /// Initializes a new <see cref="PartialType"/> instance.
        /// </summary>
        /// <param name="name">The name of the derived type to create.</param>
        /// <param name="baseType">The type to declare as the base class of <paramref name="baseType"/>.</param>
        public PartialType( string name, Type baseType )
            : this( name, baseType, baseType, null ) {
            Ensure.NotNull( name );
        }

        /// <summary>
        /// Initializes a new <see cref="PartialType"/> instance.
        /// </summary>
        /// <param name="type">The type to generate code for.</param>
        /// <param name="baseType">The type to declare as the base class of <paramref name="type"/>.</param>
        public PartialType( Type type, Type baseType )
            : this( null, type, baseType, null ) {
            Ensure.NotNull( baseType );
            Ensure.ArgSatisfies( type != baseType, "baseType", "Cannot use {0} as its own base type.", type );
        }

        /// <summary>
        /// Initializes a new <see cref="PartialType"/> instance.
        /// </summary>
        /// <param name="type">The type to generate code for.</param>
        /// <param name="baseType">The type to declare as the base class of <paramref name="type"/>.</param>
        /// <param name="silverlightBaseTypeName">The full name of the type to declare as the base type in silverlight, instead of <paramref name="baseType"/>.</param>
        public PartialType( Type type, Type baseType, string silverlightBaseTypeName )
            : this( null, type, baseType, silverlightBaseTypeName ) {
            Ensure.ArgSatisfies( type != baseType, "baseType", "Cannot use {0} as its own base type.", type );
            Ensure.NotNull( baseType, silverlightBaseTypeName );
        }


        private void AddSubNamespace( string subNamespace ) {
            if( string.IsNullOrEmpty( subNamespace ) )
                return;

            string rootNamespace = this.typeNamespace_.Split( '.' ).First( );
            this.TypeRepository.AddNamespace( rootNamespace + "." + subNamespace );
        }

        private bool TestType( Type targetType ) {
            bool isTargetType = targetType.IsAssignableFrom( this.BaseType );
            if( isTargetType )
                TypeRepository.AddNamespace( targetType );
            return isTargetType;
        }

        private IList<Member> GetMembers( ) {
            var members = new List<Member>( );

            if( this.OverrideDefaultStyleKey && this.IsStyleable ) {
                Type styleableType = TestType( typeof( FrameworkElement ) ) ? typeof( FrameworkElement ) : typeof( FrameworkContentElement );
                var defaultStyleKeyDependencyProperty = (DependencyProperty)styleableType
                    .GetField( "DefaultStyleKeyProperty", BindingFlags.Static | BindingFlags.NonPublic )
                    .GetValue( null );

                var defaultStyleKeyOverride = new MetadataOverride<object>( this, defaultStyleKeyDependencyProperty, styleableType )
                    .SetOverrideInSilverlight( TestType( typeof( Control ) ) )
                    .SetDefaultValue( this.Type );

                defaultStyleKeyOverride.Prepare( );
                members.AddRange( defaultStyleKeyOverride.Members );
            }

            members.AddRange( this.Implementers.SelectMany( i => i.Members ) );

            return members;
        }

    }

#>
<#+ // PartialType.Implementers.cs

    public sealed partial class PartialType {

        /// <summary>
        /// Assigns the values used for the <see cref="IsSealed"/> property.
        /// </summary>
        public PartialType SetIsSealed( bool isSealed ) {
            this.IsSealed = isSealed;
            return this;
        }

        /// <summary>
        /// Assigns the values used for the <see cref="ConstructorAccessibility"/> property.
        /// </summary>
        public PartialType SetConstructorAccessibility( Accessibility constructorAccessibility ) {
            this.ConstructorAccessibility = constructorAccessibility;
            return this;
        }

        /// <summary>
        /// Adds a custom suppress message attribute to the accessor.
        /// </summary>
        public PartialType AddConstructorSuppressionAttribute( string category, string id, string justification, bool staticConstructor ) {
            var attributes = staticConstructor ? this.cctorAttributes_ : this.ctorAttributes_;
            attributes.Add( AttributeMember.SuppressMessage( category, id, justification ) );
            return this;
        }

        /// <summary>
        /// Assigns the values used for the <see cref="OverrideDefaultStyleKey"/> property.
        /// </summary>
        public PartialType SetOverrideDefaultStyleKey( bool overrideDefaultStyleKey ) {
            this.OverrideDefaultStyleKey = overrideDefaultStyleKey;
            return this;
        }

        /// <summary>
        /// Adds the namespace of a type to the collection of used namespaces.
        /// </summary>
        public PartialType AddNamespace( Type type ) {
            this.TypeRepository.AddNamespace( type );
            return this;
        }

        /// <summary>
        /// Adds a namespace to the collection of used namespaces.
        /// </summary>
        public PartialType AddNamespace( string nmspace ) {
            this.TypeRepository.AddNamespace( nmspace );
            return this;
        }

        /// <summary>
        /// Inserts an arbitrary piece of text at the specified location in the generated code.
        /// </summary>
        public PartialType InsertText( InsertionPoint location, string text ) {
            if( !this.insertedText_.ContainsKey( location ) )
                this.insertedText_.Add( location, "" );
            this.insertedText_[location] += text;
            return this;
        }


        /// <summary>
        /// Adds a new <see cref="ConstantProperty{T}"/> implementer to the partial type with the specified constant value.
        /// </summary>
        [Category( "Properties" )]
        [DisplayName( "Constant Property" )]
        [Description( ConstantProperty<object>.DescriptionFormat )]
        public PartialType AddConstantProperty<T>( string name, string description, T value, Action<ConstantProperty<T>> configure = null ) {
            return this.AddImplementer( new ConstantProperty<T>( this, name, description, value ), configure );
        }
        public PartialType AddConstantProperty<T>( string name, T value, Action<ConstantProperty<T>> configure = null ) {
            return this.AddConstantProperty<T>( name, null, value, configure );
        }

        /// <summary>
        /// Adds a new <see cref="ImmutableProperty{T}"/> implementer to the partial type.
        /// </summary>
        [Category( "Properties" )]
        [DisplayName( "Immutable Property" )]
        [Description( ImmutableProperty<object>.DescriptionFormat )]
        public PartialType AddImmutableProperty<T>( string name, string description, Action<ImmutableProperty<T>> configure = null ) {
            return this.AddImplementer( new ImmutableProperty<T>( this, name, description ), configure );
        }
        public PartialType AddImmutableProperty<T>( string name, Action<ImmutableProperty<T>> configure = null ) {
            return this.AddImmutableProperty<T>( name, null, configure );
        }

        /// <summary>
        /// Adds a new <see cref="LazyProperty{T}"/> implementer to the partial type.
        /// </summary>
        [Category( "Properties" )]
        [DisplayName( "Lazy Property" )]
        [Description( LazyProperty<object>.DescriptionFormat )]
        public PartialType AddLazyProperty<T>( string name, string description, string initializerExpression, Action<LazyProperty<T>> configure = null ) where T : class {
            return this.AddImplementer( new LazyProperty<T>( this, name, description, initializerExpression ), configure );
        }
        public PartialType AddLazyProperty<T>( string name, string initializerExpression, Action<LazyProperty<T>> configure = null ) where T : class {
            return this.AddLazyProperty<T>( name, null, initializerExpression, configure );
        }

        /// <summary>
        /// Adds a new <see cref="MutableProperty{T}"/> implementer to the partial type.
        /// </summary>
        [Category( "Properties" )]
        [DisplayName( "Mutable Property" )]
        [Description( MutableProperty<object>.DescriptionFormat )]
        public PartialType AddMutableProperty<T>( string name, string description, Action<MutableProperty<T>> configure = null ) {
            return this.AddImplementer( new MutableProperty<T>( this, name, description ), configure );
        }
        public PartialType AddMutableProperty<T>( string name, Action<MutableProperty<T>> configure = null ) {
            return this.AddMutableProperty<T>( name, null, configure );
        }

        /// <summary>
        /// Adds a new <see cref="NewDependencyProperty{T}"/> implementer to the partial type.
        /// </summary>
        [Category( "Properties" )]
        [DisplayName( "Dependency Property" )]
        [Description( "Gets [or sets] {0}." )]
        public PartialType AddDependencyProperty<T>( string name, string description, Action<NewDependencyProperty<T>> configure = null ) {
            return this.AddImplementer( new NewDependencyProperty<T>( this, name, description ), configure );
        }
        public PartialType AddDependencyProperty<T>( string name, Action<NewDependencyProperty<T>> configure = null ) {
            return this.AddDependencyProperty<T>( name, null, configure );
        }

        /// <summary>
        /// Adds a new <see cref="ExistingDependencyProperty{T}"/> implementer to the partial type.
        /// </summary>
        [Category( "Properties" )]
        [DisplayName( "Existing Dependency Property" )]
        public PartialType AddDependencyProperty<T>( DependencyProperty existingProperty, Action<ExistingDependencyProperty<T>> configure ) {
            return this.AddImplementer( new ExistingDependencyProperty<T>( this, existingProperty ), configure );
        }
        public PartialType AddDependencyProperty<T>( DependencyProperty existingProperty ) {
            Action<ExistingDependencyProperty<T>> configure = null;
            return this.AddDependencyProperty<T>( existingProperty, configure );
        }
        private PartialType AddDependencyProperty<T>( DependencyProperty existingProperty, Action<IImplementer> configure ) {
            Action<ExistingDependencyProperty<T>> strongConfigure = null;
            if( configure != null )
                strongConfigure = p => configure( p );

            return this.AddDependencyProperty<T>( existingProperty, strongConfigure );
        }
        public PartialType AddDependencyProperty( DependencyProperty existingProperty, Action<IImplementer> configure ) {
            // Find definition of generic "AddDependencyProperty<T>( DependencyProperty, Action<IImplementer> )" method, 
            //  to create appropriately typed ExistingDepndencyProperty object.
            var methodDefinition =
                (from m in this.GetType( ).GetMethods( BindingFlags.NonPublic | BindingFlags.Instance )
                 where m.IsGenericMethodDefinition
                    && m.Name == "AddDependencyProperty"
                 let parameters = m.GetParameters( )
                 where parameters.Length == 2
                    && parameters[0].ParameterType == typeof( DependencyProperty )
                    && parameters[1].ParameterType == typeof( Action<IImplementer> )
                 select m
                ).Single( );

            var method = methodDefinition.MakeGenericMethod( existingProperty.PropertyType );
            return (PartialType)method.Invoke( this, new object[] { existingProperty, configure } );
        }
        public PartialType AddDependencyProperty( DependencyProperty existingProperty ) { return this.AddDependencyProperty( existingProperty, null ); }

        /// <summary>
        /// Adds a new <see cref="MetadataOverride{T}"/> implementer to the partial type.
        /// </summary>
        [Category( "Framework" )]
        [DisplayName( "Metadata Override" )]
        public PartialType AddMetadataOverride<T>( DependencyProperty existingProperty, Action<MetadataOverride<T>> configure ) {
            return this.AddImplementer( new MetadataOverride<T>( this, existingProperty ), configure );
        }
        public PartialType AddMetadataOverride<T>( DependencyProperty existingProperty, T defaultValue ) {
            return this.AddImplementer( new MetadataOverride<T>( this, existingProperty ), o => o.SetDefaultValue( defaultValue ) );
        }

        /// <summary>
        /// Adds a new <see cref="TemplatePart{T}"/> implementer to the partial type.
        /// </summary>
        [Category( "Framework" )]
        [DisplayName( "Template Part" )]
        [Description( TemplatePart<object>.DescriptionFormat )]
        public PartialType AddTemplatePart<T>( string name, string description, Action<TemplatePart<T>> configure = null ) where T : class {
            return this.AddImplementer( new TemplatePart<T>( this, name, description ), configure );
        }
        public PartialType AddTemplatePart<T>( string name, Action<TemplatePart<T>> configure = null ) where T : class {
            return this.AddTemplatePart<T>( name, null, configure );
        }

        /// <summary>
        /// Adds a new <see cref="Event{T}"/> implementer to the partial type.
        /// </summary>
        [Category( "Events" )]
        [DisplayName( "Event" )]
        [Description( Event<object>.DescriptionFormat )]
        public PartialType AddEvent<T>( string name, string description, Action<Event<T>> configure = null ) {
            return this.AddImplementer( new Event<T>( this, name, description ), configure );
        }
        public PartialType AddEvent<T>( string name, Action<Event<T>> configure = null ) {
            return this.AddEvent<T>( name, null, configure );
        }


        /// <summary>
        /// Adds a new <see cref="NotifyPropertyChangedInterface"/> implementer to the partial type.
        /// </summary>
        [Category( "Interfaces" )]
        [DisplayName( "INotifyPropertyChanged" )]
        public PartialType ImplementINotifyPropertyChanged( Action<NotifyPropertyChangedInterface> configure = null ) {
            return this.AddImplementer( new NotifyPropertyChangedInterface( this ), configure );
        }

        /// <summary>
        /// Adds a new <see cref="EquatableInterface"/> implementer to the partial type.
        /// </summary>
        [Category( "Interfaces" )]
        [DisplayName( "IEquatable" )]
        public PartialType ImplementIEquatable( string[] equatablePropertyNames, Action<EquatableInterface> configure = null ) {
            // Mark all specified properties as equatable.
            var targets = this.Implementers.OfType<EquatableInterface.ITarget>( );
            EquatableInterface.ITarget[] equatableProperties;
            if( equatablePropertyNames == null ) {
                equatableProperties = targets.ToArray( );
            }
            else {
                equatableProperties = equatablePropertyNames
                    .Join( targets, name => name, prop => prop.Name, ( name, prop ) => prop, StringComparer.OrdinalIgnoreCase )
                    .ToArray( );

                // Ensure that all equatable properties were found.
                if( equatableProperties.Length != equatablePropertyNames.Length ) {
                    string[] missingNames =
                        equatablePropertyNames
                            .Where( name => !equatableProperties.Any( p => name.Equals( p.Name, StringComparison.OrdinalIgnoreCase ) ) )
                            .ToArray( );
                    Ensure.Satisfies( false, "Could not find equatable properties for all names: {0}", string.Join( ", ", missingNames ) );
                }
            }

            foreach( var property in equatableProperties ) {
                property.Equatable = true;
            }

            return this.AddImplementer( new EquatableInterface( this ), configure );
        }
        public PartialType ImplementIEquatable( params string[] equatablePropertyNames ) { return this.ImplementIEquatable( equatablePropertyNames, null ); }


        /// <summary>
        /// Adds a new <see cref="PropertyNameConstants"/> implementer to the partial type.
        /// </summary>
        [Category( "Misc" )]
        [DisplayName( "Property Name Constants" )]
        public PartialType ImplementPropertyNameConstants( Action<PropertyNameConstants> configure = null ) {
            return this.AddImplementer( new PropertyNameConstants( this ), configure );
        }


        private PartialType AddImplementer<T>( T implementer, Action<T> configure )
            where T : IImplementer {
            Ensure.NotNull( implementer );

            if( configure != null )
                configure( implementer );

            this.implementers_.Add( implementer );

            return this;
        }

    }

#>
<#+ // StringBuilderCodeWriter.cs

    public sealed class StringBuilderCodeWriter : CodeWriter {

        public static readonly string[] EmptyLines = new[] { "" };


        private readonly StringBuilder writer_ = new StringBuilder( );


        public override string ToString( ) {
            return this.writer_.ToString( );
        }

        public string[] GetLines( ) {
            return this.ToString( ).Split( new[] { Environment.NewLine }, StringSplitOptions.None );
        }


        protected override void WriteCore( string value ) {
            this.writer_.Append( value );
        }

        protected override void WriteLineCore( string value ) {
            this.writer_.AppendLine( value );
        }

    }

#>
<#+ // TypeRepository.cs

    /// <summary>
    /// Returns the string representation of types, saving the used namespaces.
    /// </summary>
    public sealed class TypeRepository {

        /// <summary>
        /// Gets the collection of type namespaces added automatically through <see cref="GetTypeName"/> or manually through <see cref="AddNamespace"/>.
        /// </summary>
        public IEnumerable<string> UsedNamespaces { get { return this.namespaces_.Where( n => n.Length > 0 ); } }

        /// <summary>
        /// Adds a global name alias for the specified type.
        /// </summary>
        /// <param name="type">The type to alias.</param>
        /// <param name="alias">The alias name.</param>
        /// <returns>An object that can be used to remove the global alias.</returns>
        public static IDisposable AddGlobalAlias( Type type, string alias ) {
            Ensure.NotNull( type );
            Ensure.NotNullOrEmpty( alias );

            AliasedTypes[type] = alias;
            return new RemoveGlobalAlias( type );
        }

        /// <summary>
        /// Adds a namespace to the collection of used namespaces.
        /// </summary>
        /// <param name="nmspace">The namespace to add.</param>
        public void AddNamespace( string nmspace ) {
            Ensure.NotNull( nmspace );

            if( !this.namespaces_.Contains( nmspace ) )
                this.namespaces_.Add( nmspace );
        }

        /// <summary>
        /// Adds the namespace of a type to the collection of used namespaces.
        /// </summary>
        /// <param name="type">The type to add a namespace for.</param>
        public void AddNamespace( Type type ) {
            Ensure.NotNull( type );

            string nmspace = GetTypeNamespaceCore( type );
            this.AddNamespace( nmspace );
        }

        /// <summary>
        /// Gets the namespace of the specified type.
        /// </summary>
        /// <param name="type">The type to use.</param>
        /// <returns>The namespace of <paramref name="type"/>.</returns>
        public string GetTypeNamespace( Type type ) {
            Ensure.NotNull( type );

            return GetTypeNamespaceCore( type );
        }

        /// <summary>
        /// Gets the name of the specified type that can be used in a generated code file.
        /// </summary>
        /// <param name="type">The type to name.</param>
        /// <returns>The name of <paramref name="type"/>.</returns>
        public string GetTypeName( Type type ) {
            Ensure.NotNull( type );

            if( !this.typeNames_.ContainsKey( type ) )
                this.typeNames_[type] = this.GetTypeNameCore( type );
            return this.typeNames_[type];
        }

        /// <summary>
        /// Gets the simple name of the type, removing any generic parameters.
        /// </summary>
        /// <param name="type">The type to name.</param>
        /// <returns>The simple name of <paramref name="type"/>, without any generic parameters.</returns>
        public string GetSimpleTypeName( Type type ) {
            Ensure.NotNull( type );

            if( type.IsArray )
                return GetSimpleTypeName( type.GetElementType( ) );

            string typeName = CommonTypes.ContainsKey( type ) ? CommonTypes[type] : type.Name;
            int index = typeName.IndexOf( '`' );
            if( index > 0 )
                typeName = typeName.Substring( 0, index );

            return typeName;
        }


        /// <summary>
        /// Gets the string representation of the specified value.
        /// </summary>
        /// <typeparam name="T">The type of the value.</typeparam>
        /// <param name="value">The value to retrieve a string representation for.</param>
        /// <param name="silverlight">Whether the value needs to be Silverlight-compatible.</param>
        /// <returns>The string representation of <paramref name="value"/>.</returns>
        public string GetValueString<T>( T value, bool silverlight ) {
            if( value == null )
                return "null";

            string stringValue = value.ToString( );

            if( value is string )
                return EscapeString( stringValue );

            if( typeof( T ).IsEnum ) {
                var flags = stringValue.Split( ',' );
                string valueTypeName = this.GetTypeName( typeof( T ) );
                return Util.Join( flags, " | ", ( i, flag ) => valueTypeName + "." + flag.Trim( ) );
            }

            var boolean = value as bool?;
            if( boolean != null )
                return boolean.Value ? "true" : "false";

            var real = value as double?;
            if( real != null ) {
                if( double.IsNaN( real.Value ) )
                    return "double.NaN";
                if( double.IsPositiveInfinity( real.Value ) )
                    return "double.PositiveInfinity";
                if( double.IsNegativeInfinity( real.Value ) )
                    return "double.NegativeInfinity";
            }

            var size = value as Size?;
            if( size != null ) {
                if( size.Value.IsEmpty )
                    return "Size.Empty";

                string widthValueString = GetValueString( size.Value.Width, silverlight );
                string heightValueString = GetValueString( size.Value.Height, silverlight );
                return string.Format( "new {0}({1}, {2})", typeof( Size ).Name, widthValueString, heightValueString );
            }

            var point = value as Point?;
            if( point != null ) {
                string widthValueString = GetValueString( point.Value.X, silverlight );
                string heightValueString = GetValueString( point.Value.Y, silverlight );
                return string.Format( "new {0}({1}, {2})", typeof( Point ).Name, widthValueString, heightValueString );
            }

            var thickness = value as Thickness?;
            if( thickness != null ) {
                string topValueString = GetValueString( thickness.Value.Top, silverlight );
                string leftValueString = GetValueString( thickness.Value.Left, silverlight );
                string rightValueString = GetValueString( thickness.Value.Right, silverlight );
                string bottomValueString = GetValueString( thickness.Value.Bottom, silverlight );
                bool same = new HashSet<string> { topValueString, leftValueString, rightValueString, bottomValueString }.Count == 1;
                string format = "new {0}({1}" + (same ? "" : ", {2}, {3}, {4}") + ")";
                return string.Format( format, typeof( Thickness ).Name, leftValueString, topValueString, rightValueString, bottomValueString );
            }

            var brush = value as SolidColorBrush;
            if( brush != null ) {
                Color color = brush.Color;
                string colorName = GetColorName( color );

                string format;
                if( colorName == null )
                    format = "new SolidColorBrush(Color.FromArgb(0x{1:x}, 0x{2:x}, 0x{3:x}, 0x{4:x}))";
                else if( silverlight )
                    format = "new SolidColorBrush(Colors.{0})";
                else
                    format = "Brushes.{0}";

                return string.Format( format, colorName, color.A, color.R, color.G, color.B );
            }

            var type = value as Type;
            if( type != null )
                return string.Format( "typeof({0})", this.GetTypeName( type ) );

            return stringValue;
        }


        /// <summary>
        /// Escapes the specified string value.
        /// </summary>
        /// <param name="value">The value to escape.</param>
        /// <returns>The escaped string value.</returns>
        public static string EscapeString( string value ) {
            return value.Length == 0
                 ? "string.Empty"
                 : '"' + value + '"';
        }


        #region Private

        private static readonly Dictionary<Color, string> Colors = typeof( Colors )
            .GetProperties( BindingFlags.Public | BindingFlags.Static )
            .Distinct( new PropertyComparer( ) )
            .ToDictionary( p => (Color)p.GetValue( null, null ), p => p.Name );

        private static string GetColorName( Color color ) {
            return Colors.ContainsKey( color ) ? Colors[color] : null;
        }

        private sealed class PropertyComparer : IEqualityComparer<PropertyInfo> {
            public bool Equals( PropertyInfo x, PropertyInfo y ) {
                object xValue = x.GetValue( null, null );
                object yValue = y.GetValue( null, null );
                return object.Equals( xValue, yValue );
            }

            public int GetHashCode( PropertyInfo obj ) {
                object value = obj.GetValue( null, null );
                return value.GetHashCode( );
            }
        }

        private sealed class RemoveGlobalAlias : IDisposable {
            private readonly Type type_;

            public RemoveGlobalAlias( Type type ) {
                this.type_ = type;
            }

            public void Dispose( ) {
                AliasedTypes.Remove( this.type_ );
            }
        }



        private readonly List<string> namespaces_ = new List<string>( );

        private readonly Dictionary<Type, string> typeNames_ = new Dictionary<Type, string>( );

        private static readonly Dictionary<Type, string> CommonTypes = new Dictionary<Type, string>{
            { typeof( void ),   "void" },
            { typeof( object ), "object" },
            { typeof( bool ),   "bool" },
            { typeof( char ),   "char" },
            { typeof( int ),    "int" },
            { typeof( uint ),   "uint" },
            { typeof( long ),   "long" },
            { typeof( double ), "double" },
            { typeof( string ), "string" },
        };

        private static readonly Dictionary<Type, string> AliasedTypes = new Dictionary<Type, string>( );


        private static string GetTypeNamespaceCore( Type type ) {
            if( type.IsArray )
                return GetTypeNamespaceCore( type.GetElementType( ) );

            var templateType = Util.GetAttribute<TemplateTypeAttribute>( type );
            if( templateType != null )
                return templateType.Namespace ?? "";

            var aliasType = Util.GetAttribute<AliasTypeAttribute>( type );
            if( aliasType != null )
                return GetAliasTypeNamespaceCore( type.Name, aliasType.Alias );

            if( AliasedTypes.ContainsKey( type ) )
                return GetAliasTypeNamespaceCore( AliasedTypes[type], type );

            return type.Namespace;
        }

        private static string GetAliasTypeNamespaceCore( string alias, Type aliasedType ) {
            return alias + " = " + aliasedType.FullName;
        }

        private string GetTypeNameCore( Type type ) {
            string typeNamespace = GetTypeNamespaceCore( type );
            if( !string.IsNullOrEmpty( typeNamespace ) )
                this.AddNamespace( typeNamespace );

            if( type.IsGenericType )
                return type.GetGenericArguments( ).Aggregate(
                    new StringBuilder( type.Name.Substring( 0, type.Name.IndexOf( '`' ) ) + "<" ),
                    ( sb, t ) => sb.Append( this.GetTypeName( t ) ).Append( ", " ),
                    ( sb ) => { sb[sb.Length - 2] = '>'; return sb.ToString( 0, sb.Length - 1 ); }
                );

            if( CommonTypes.ContainsKey( type ) )
                return CommonTypes[type];

            if( AliasedTypes.ContainsKey( type ) )
                return AliasedTypes[type];

            if( type.IsArray ) {
                int rank = type.GetArrayRank( );
                Type elementType = type.GetElementType( );
                return GetTypeNameCore( elementType ) + "[" + new string( ',', rank - 1 ) + "]";
            }

            return type.Name;
        }

        #endregion

    }

#>
<#+ // Util.cs

    /// <summary>
    /// Contains utility methods for performing common operations.
    /// </summary>
    public static class Util {

        /// <summary>
        /// Capitalizes the specified string.
        /// </summary>
        /// <param name="value">The string to be capitalized.</param>
        /// <returns>The original string with the first character capitalized.</returns>
        public static string Capitalize( string value ) {
            Ensure.NotNullOrEmpty( value );
            return char.ToUpperInvariant( value[0] ) + value.Substring( 1 );
        }

        /// <summary>
        /// Lowercases the specified string.
        /// </summary>
        /// <param name="value">The string to be lowercased.</param>
        /// <returns>The original string with the first character lowercased.</returns>
        public static string Lowercase( string value ) {
            Ensure.NotNullOrEmpty( value );
            return value.Length > 1 && char.IsUpper( value, 1 )
                ? value // Don't lowercase acronyms.
                : char.ToLowerInvariant( value[0] ) + value.Substring( 1 );
        }


        /// <summary>
        /// Enumerates a linked collection of items.
        /// </summary>
        /// <typeparam name="T">The type of the item to enumerate.</typeparam>
        /// <param name="start">The item to enumerate.</param>
        /// <param name="next">The function used to return the next item.</param>
        /// <returns>The linked collection of items.</returns>
        public static IEnumerable<T> Enumerate<T>( T start, Func<T, T> next )
            where T : class {
            next = next ?? (_ => null);
            for( T item = start; item != null; item = next( item ) )
                yield return item;
        }


        /// <summary>
        /// Joins the collection of strings with the specified separator.
        /// </summary>
        /// <param name="collection">The strings to join.</param>
        /// <param name="separator">The separator to join the strings with.</param>
        /// <returns>A string containing each string in <paramref name="collection"/> separated by <paramref name="separator"/>.</returns>
        public static string Join( IEnumerable<string> collection, string separator ) {
            return Util.Join( collection, separator, ( i, s ) => s );
        }

        /// <summary>
        /// Joins the collection of objects with the specified separator after converting each object to a string.
        /// </summary>
        /// <typeparam name="T">The type of objects to join.</typeparam>
        /// <param name="collection">The objects to join.</param>
        /// <param name="separator">The separator to join the string representations of the objects.</param>
        /// <param name="toString">A method for converting an object to a string.</param>
        /// <returns>A string containing the string representation returned by <paramref name="toString"/> of each object in <paramref name="collection"/> separated by <paramref name="separator"/>.</returns>
        public static string Join<T>( IEnumerable<T> collection, string separator, Func<int, T, string> toString ) {
            return Util.Join( collection, ( i, last ) => separator, toString );
        }

        /// <summary>
        /// Joins the collection of objects using the separator returned for each join after converting each object to a string.
        /// </summary>
        /// <typeparam name="T">The type of objects to join.</typeparam>
        /// <param name="collection">The objects to join.</param>
        /// <param name="separator">A method for generating a string separator to join two objects, either in the middle or at the end of the collection.</param>
        /// <param name="toString">A method for converting an object to a string.</param>
        /// <returns>A string containing the string representation returned by <paramref name="toString"/> of each object in <paramref name="collection"/> separated by the strings returned by <paramref name="separator"/>.</returns>
        public static string Join<T>( IEnumerable<T> collection, Func<int, bool, string> separator, Func<int, T, string> toString ) {
            Ensure.NotNull( collection, separator, toString );

            var sb = new StringBuilder( );
            Util.Iterate(
                collection,
                ( i, last ) => sb.Append( separator( i, last ) ),
                ( i, item ) => sb.Append( toString( i, item ) )
            );

            return sb.ToString( );
        }


        /// <summary>
        /// Iterates over a collection of objects, performing an operation on and separating each object.
        /// </summary>
        /// <typeparam name="T">The type of objects to iterate over.</typeparam>
        /// <param name="collection">The objects to iterate over.</param>
        /// <param name="separate">An action to perform between each pair of objects, either in the middle or at the end of the collection.</param>
        /// <param name="operate">An action to perform on each object.</param>
        public static void Iterate<T>( IEnumerable<T> collection, Action<int, bool> separate, Action<int, T> operate ) {
            Ensure.NotNull( collection, separate, operate );

            T[] items = collection.ToArray( );
            for( int i = 0; i < items.Length; ++i ) {
                if( i > 0 ) {
                    bool isLastSeparator = (i == items.Length - 1);
                    separate( i, isLastSeparator );
                }

                T item = items[i];
                operate( i, item );
            }
        }


        /// <summary>
        /// Retrieves the first attribute of the specified type on the member, or <null/> if the attribute could not be found.
        /// </summary>
        /// <typeparam name="T">The type of attribute to look for.</typeparam>
        /// <param name="member">The member with the desired attribute.</param>
        /// <returns>The first attribute of type <typeparamref name="T"/> declared on <paramref name="member"/>, or <null/> if no attributes of type <typeparamref name="T"/> where found.</returns>
        public static T GetAttribute<T>( MemberInfo member )
            where T : Attribute {
            Ensure.NotNull( member );

            return member.GetCustomAttributes( typeof( T ), true )
                .Cast<T>( )
                .FirstOrDefault( );
        }


        /// <summary>
        /// Gets the aggregate set of <see cref="Extensions"/> used by all of the specified members.
        /// </summary>
        /// <param name="members">The collection of <see cref="Member"/> objects to examine.</param>
        /// <returns>The set of <see cref="Extensions"/> used by all <paramref name="members"/>.</returns>
        public static Extensions GetUsedExtensions( IEnumerable<Member> members ) {
            return members
                .Where( m => m != null )
                .Aggregate( Extensions.None, ( e, m ) => e | m.UsedExtensions );
        }

        /// <summary>
        /// Gets the aggregate set of <see cref="Extensions"/> used by all of the specified members.
        /// </summary>
        /// <param name="members">The collection of <see cref="Member"/> objects to examine.</param>
        /// <returns>The set of <see cref="Extensions"/> used by all <paramref name="members"/>.</returns>
        public static Extensions GetUsedExtensions( params Member[] members ) {
            return GetUsedExtensions( members.AsEnumerable( ) );
        }

    }

#>
<#+ // XmlDocumentation.cs

    /// <summary>
    /// Retrieves XML documentation for members from existing .NET libraries.
    /// </summary>
    /// <seealso href="http://stackoverflow.com/questions/230925/retrieve-xml-doc-comments-programmatically"/>
    public static class XmlDocumentation {

        public static string CombinePath( params string[] pathSegments ) {
            Ensure.NotNullOrEmpty( pathSegments );

            var path = pathSegments.Aggregate( System.IO.Path.Combine );
            return path;
        }


        public static string GetMemberId( MemberInfo member ) {
            Ensure.NotNull( member );

            char memberKindPrefix = GetMemberPrefix( member );
            string memberName = GetMemberFullName( member );
            return memberKindPrefix + ":" + memberName;
        }

        public static string GetElementName( XElement element ) {
            string elementAttributes = Util.Join( element.Attributes( ), "", ( i, a ) => " " + a.ToString( ) );
            string elementName = element.Name.LocalName + elementAttributes;
            return RemoveRawReferences( elementName );
        }

        public static string GetElementValue( XElement element ) {
            Ensure.NotNull( element );

            string[] nodeValues = Util.Enumerate( element.FirstNode, n => n.NextNode )
                .Select( n => RemoveRawReferences( n.ToString( ).Trim( ) ) )
                .Where( v => v.Length > 0 )
                .ToArray( );

            string value = Util.Join(
                nodeValues,
                ( i, last ) => char.IsPunctuation( nodeValues[i], 0 ) ? "" : " ",
                ( i, v ) => v
            );

            return value;
        }

        public static IEnumerable<XElement> FilterElements( IEnumerable<XElement> elements, params string[] excludedNames ) {
            Ensure.NotNull( elements, excludedNames );

            return elements.Where( e => !excludedNames.Contains( e.Name.LocalName ) );
        }

        public static IEnumerable<XElement> FilterElements( XElement element, params string[] excludedNames ) {
            Ensure.NotNull( element );
            return FilterElements( element.Elements( ), excludedNames );
        }


        public static bool HasXmlDocumentation( Assembly assembly ) {
            return GetXmlDocFile( assembly ) != null;
        }

        public static XElement GetDocMember( MemberInfo member ) {
            Ensure.NotNull( member );

            Assembly assembly = (member.DeclaringType ?? (Type)member).Assembly;
            Ensure.ArgSatisfies( HasXmlDocumentation( assembly ), "member", "Member " + member + " is undocumented." );

            XDocument docFile = GetXmlDocFile( assembly );
            string memberId = GetMemberId( member );

            var docMembers =
                from element in docFile.Root.Element( "members" ).Elements( "member" )
                let name = element.Attribute( "name" ).Value
                where name == memberId
                select element;

            var docMember = docMembers.First( );
            return docMember;
        }

        public static string GetSummary( MemberInfo member ) {
            var xmldoc = XmlDocumentation.GetDocMember( member );
            var summary = xmldoc.Element( "summary" );
            return summary.Value.Trim( );
        }


        #region Private

        private static readonly Dictionary<string, XDocument> DocumentationCache = new Dictionary<string, XDocument>( );

        private static readonly string[] SystemSearchDirectories;
        private static readonly string[] FallbackDirectoryNames;

        static XmlDocumentation( ) {
            // Reference a type from required assembly System.Xml.
            new System.Xml.NameTable( );

            var systemDir = new System.IO.DirectoryInfo( Environment.GetFolderPath( Environment.SpecialFolder.System ) );
            string frameworkDirPath = CombinePath( systemDir.Parent.FullName, "Microsoft.NET", "Framework" );
            var frameworkDirChildren = System.IO.Directory.GetDirectories( frameworkDirPath ).OrderByDescending( path => path );

            string referenceAssembliesDirPath = CombinePath( Environment.GetFolderPath( Environment.SpecialFolder.ProgramFiles ), "Reference Assemblies", "Microsoft", "Framework", ".NETFramework" );
            if( !System.IO.Directory.Exists( referenceAssembliesDirPath ) )
                referenceAssembliesDirPath = CombinePath( Environment.GetFolderPath( Environment.SpecialFolder.ProgramFilesX86 ), "Reference Assemblies", "Microsoft", "Framework", ".NETFramework" );
            var referenceAssembliesDirChildren = System.IO.Directory.GetDirectories( referenceAssembliesDirPath ).OrderByDescending( path => path );

            SystemSearchDirectories = frameworkDirChildren
                .Concat( referenceAssembliesDirChildren )
                .ToArray( );


            var fallbackNames = new List<string>( );
            var culture = System.Globalization.CultureInfo.CurrentCulture;
            while( !fallbackNames.Contains( culture.Name ) ) {
                fallbackNames.Add( culture.Name );
                culture = culture.Parent;
            }
            FallbackDirectoryNames = fallbackNames.ToArray( );
        }


        private static char GetMemberPrefix( MemberInfo member ) {
            string memberTypeName = member.GetType( ).Name;
            char initial = memberTypeName
                .Replace( "Runtime", "" )
                .Replace( "Rt", "" )
                .Replace( "Md", "" )
                [0];

            // Correction for ConstructorInfo.
            initial = (initial == 'C' ? 'M' : initial);

            return initial;
        }

        private static string GetMemberFullName( MemberInfo member ) {
            Type type = member as Type;
            if( type != null && type.IsGenericParameter ) {
                string prefix;
                Type[] parameters;

                Type[] methodParameters = type.DeclaringMethod != null ? type.DeclaringMethod.GetGenericArguments( ) : Type.EmptyTypes;
                if( methodParameters.Contains( type ) ) {
                    parameters = methodParameters;
                    prefix = "``";
                }
                else {
                    parameters = type.DeclaringType.GetGenericArguments( );
                    prefix = "`";
                }

                return prefix + Array.IndexOf( parameters, type );
            }

            string memberScope = "";
            if( member.DeclaringType != null )
                memberScope = GetMemberFullName( member.DeclaringType );
            else if( type != null )
                memberScope = type.Namespace;

            string memberName = member.Name;
            string arguments = "";
            if( member is MethodBase ) {
                if( member is ConstructorInfo ) {
                    memberName = ((ConstructorInfo)member).IsStatic ? "#cctor" : "#ctor";
                }
                else {
                    int genericArgCount = ((MethodInfo)member).GetGenericArguments( ).Length;
                    if( genericArgCount > 0 )
                        memberName += "``" + genericArgCount;
                }

                arguments = Util.Join( ((MethodBase)member).GetParameters( ), ",", ( i, p ) => GetMemberFullName( p.ParameterType ) );
            }
            if( arguments.Length > 0 )
                arguments = "(" + arguments + ")";

            return memberScope + "." + memberName + arguments;
        }


        private static string RemoveRawReferences( string value ) {
            const string RawReferencePrefix = " cref=\"";

            for( int i = value.IndexOf( RawReferencePrefix ); i > 0; i = value.IndexOf( RawReferencePrefix, i + 1 ) ) {
                int colonIndex = i + RawReferencePrefix.Length + 1;
                if( value[colonIndex] == ':' ) {
                    string rawMemberPrefix = string.Format( "\"{0}:", value[colonIndex - 1] );
                    value = value.Replace( rawMemberPrefix, "\"" );
                }
            }

            return value;
        }


        private static XDocument GetXmlDocFile( Assembly assembly ) {
            Ensure.NotNull( assembly );

            if( string.IsNullOrEmpty( assembly.Location ) )
                return null;


            string fileName = System.IO.Path.GetFileNameWithoutExtension( assembly.Location ) + ".xml";

            if( !DocumentationCache.ContainsKey( fileName ) ) {
                string assemblyDirPath = System.IO.Path.GetDirectoryName( assembly.Location );
                var docFile =
                    from baseDir in new[] { assemblyDirPath }.Concat( SystemSearchDirectories )
                    from dirName in FallbackDirectoryNames
                    let filePath = CombinePath( baseDir, dirName, fileName )
                    let file = new System.IO.FileInfo( filePath )
                    where file.Exists
                    select file;

                var firstDocFile = docFile.FirstOrDefault( );
                DocumentationCache[fileName] = (firstDocFile == null ? null : XDocument.Load( firstDocFile.FullName ));
            }

            return DocumentationCache[fileName];
        }

        #endregion

    }

#>
<#+ // AccessorImplementer`T.cs

    /// <summary>
    /// Implements an accessor, such as a property or event.
    /// </summary>
    /// <typeparam name="T">The type of the accessor.</typeparam>
    public abstract class AccessorImplementer<T> : Implementer<T> {

        private readonly List<Guard> guards_ = new List<Guard>( );
        private readonly List<AttributeMember> attributes_ = new List<AttributeMember>( );


        /// <summary>
        /// Gets or sets a value indicating the accessibility of a member.
        /// </summary>
        public Accessibility Accessibility { get; set; }

        /// <summary>
        /// Gets or sets a value indicating how a member is inherited.
        /// </summary>
        public Inheritance Inheritance { get; set; }

        /// <summary>
        /// Gets or sets a value indicating the design category of the member.
        /// </summary>
        public string Category { get; set; }

        /// <summary>
        /// Gets the collection of argument guards for the accessor.
        /// </summary>
        public IEnumerable<Guard> Guards { get { return this.guards_.Where( g => !g.IsValueGuard ); } }

        /// <summary>
        /// Gets the collection of value guards for the accessor.
        /// </summary>
        public IEnumerable<Guard> AccessorGuards { get { return this.guards_.Where( g => g.IsValueGuard ); } }

        /// <summary>
        /// Gets the collection of attributes for the accessor.
        /// </summary>
        public IEnumerable<AttributeMember> Attributes {
            get {
                if( this.Category != null ) {
                    var typeRepository = this.Parent.TypeRepository;
                    string typeName = typeRepository.GetTypeName( typeof( CategoryAttribute ) );
                    string argValue = typeRepository.GetValueString( this.Category, false );
                    yield return AttributeMember.Custom( typeName, argValue );
                }

                foreach( AttributeMember attribute in this.attributes_ )
                    yield return attribute;
            }
        }


        /// <summary>
        /// Gets the name of the accessor's backing field.
        /// </summary>
        public virtual string FieldName { get { return this.FieldNamePrefix + this.AccessorName; } }

        /// <summary>
        /// Gets the name of the accessor's backing field type.
        /// </summary>
        public virtual string FieldTypeName { get { return this.TypeName; } }

        /// <summary>
        /// Gets the modifiers on the accessor's backing field.
        /// </summary>
        public virtual string FieldModifiers { get { return "private"; } }


        /// <summary>
        /// Gets the public name of the accessor.
        /// </summary>
        public string AccessorName { get { return this.MemberName; } }

        /// <summary>
        /// Gets the modifiers on the accessor.
        /// </summary>
        public string AccessorModifiers { get { return this.GetAccessibilityValue( ) + this.GetInheritanceValue( ); } }


        /// <summary>
        /// Gets the prefix for the accessor's backing field.
        /// </summary>
        protected abstract string FieldNamePrefix { get; }

        /// <summary>
        /// Gets the backing field member for the accessor, if any.
        /// </summary>
        protected virtual IEnumerable<FieldMember> Fields {
            get { yield return new FieldMember( this.FieldName, this.FieldTypeName ) { Modifiers = this.FieldModifiers }; }
        }

        /// <summary>
        /// Gets the initialization members for the accessor.
        /// </summary>
        protected abstract IEnumerable<InitializationMember> Initializers { get; }

        /// <summary>
        /// Gets the accessor member for the accessor.
        /// </summary>
        protected abstract AccessorMember Accessor { get; }

        /// <inheritdoc/>
        protected override bool EnsureDescription {
            get { return base.EnsureDescription && this.Accessibility < Accessibility.Internal; }
        }


        /// <inheritdoc/>
        protected AccessorImplementer( PartialType parent, string name, string description )
            : base( parent, name, description ) { }


        /// <summary>
        /// Ensures the accessor satisfies the requirements defined by the specified condition.
        /// </summary>
        public AccessorImplementer<T> AccessorSatisfies( string description, Action<Guard> configure, string condition, string format, params string[] args ) {
            return this.AddGuard( Guard.AccessorSatisfies( this.CreateDoc( ), "this", description, condition, format, args ), configure );
        }
        public AccessorImplementer<T> AccessorSatisfies( string description, string condition, string format, params string[] args ) { return this.AccessorSatisfies( description, null, condition, format, args ); }

        /// <summary>
        /// Adds a new guard to the accessor.
        /// </summary>
        public AccessorImplementer<T> AddGuard( Guard guard, Action<Guard> configure ) {
            Ensure.NotNull( guard );

            if( configure != null )
                configure( guard );

            this.guards_.Add( guard );
            return this;
        }


        /// <summary>
        /// Assigns the values used for the <see cref="Accessibility"/> property.
        /// </summary>
        public AccessorImplementer<T> SetAccessibility( Accessibility accessibility ) {
            this.Accessibility = accessibility;
            return this;
        }

        /// <summary>
        /// Assigns the values used for the <see cref="Inheritance"/> property.
        /// </summary>
        public AccessorImplementer<T> SetInheritance( Inheritance inheritance ) {
            this.Inheritance = inheritance;
            return this;
        }

        /// <summary>
        /// Assigns the values used for the <see cref="Category"/> property.
        /// </summary>
        public AccessorImplementer<T> SetCategory( string category ) {
            this.Category = category;
            return this;
        }

        /// <summary>
        /// Adds a custom attribute to the accessor.
        /// </summary>
        public AccessorImplementer<T> AddAttribute( Type type, CompilationSymbol condition, string[] positionalArguments, params string[] namedArguments ) {
            Ensure.Satisfies( typeof( Attribute ).IsAssignableFrom( type ), "{0} is not an Attribute type.", type );

            string typeName = this.Parent.TypeRepository.GetTypeName( type );
            var attribute = AttributeMember.Custom( typeName, positionalArguments );
            attribute.Condition = condition;

            for( int i = 0; i < namedArguments.Length; ++i ) {
                string namedArgument = namedArguments[i];
                string[] nameValue = namedArgument.Split( new[] { '=' }, 2, StringSplitOptions.RemoveEmptyEntries );
                string name = nameValue[0];
                string value = nameValue[1];

                attribute.NamedArguments[name] = value;
            }

            this.attributes_.Add( attribute );
            return this;
        }
        public AccessorImplementer<T> AddAttribute( Type type, string[] positionalArguments, params string[] namedArguments ) { return this.AddAttribute( type, CompilationSymbol.None, positionalArguments, namedArguments ); }

        /// <summary>
        /// Adds a custom attribute to the accessor.
        /// </summary>
        public AccessorImplementer<T> AddAttribute<TArg>( Type type, CompilationSymbol condition, TArg arg ) {
            Ensure.Satisfies( typeof( Attribute ).IsAssignableFrom( type ), "{0} is not an Attribute type.", type );

            var typeRepository = this.Parent.TypeRepository;
            string typeName = typeRepository.GetTypeName( type );
            string argValue = typeRepository.GetValueString( arg, false );
            AttributeMember attribute = AttributeMember.Custom( typeName, argValue );
            attribute.Condition = condition;
            this.attributes_.Add( attribute );

            return this;
        }
        public AccessorImplementer<T> AddAttribute<TArg>( Type type, TArg arg ) { return this.AddAttribute<TArg>( type, CompilationSymbol.None, arg ); }

        /// <summary>
        /// Adds a custom suppress message attribute to the accessor.
        /// </summary>
        public AccessorImplementer<T> AddSuppressionAttribute( string category, string id, string justification ) {
            this.attributes_.Add( AttributeMember.SuppressMessage( category, id, justification ) );
            return this;
        }


        /// <inheritdoc/>
        protected override IEnumerable<Member> GetMembers( ) {
            foreach( var field in this.Fields )
                yield return field;

            foreach( var initializer in this.Initializers )
                yield return initializer;

            var accessor = this.Accessor;
            Ensure.NotNull( accessor );
            accessor.AddAttributes( this.Attributes );
            yield return accessor;
        }

        /// <summary>
        /// Gets the member name of the specified action for this implementer.
        /// </summary>
        protected string GetActionName( string action ) {
            return this.AccessorName + action;
        }

        /// <summary>
        /// Creates a new <see cref="BlockMember"/> for an accessor.
        /// </summary>
        protected BlockMember CreateAccessorBlock( string name, string content ) {
            return InitializeAccessorBlock( new BlockMember( name, content ) );
        }

        /// <summary>
        /// Creates a new <see cref="BlockMember"/> for an accessor.
        /// </summary>
        protected BlockMember CreateAccessorBlock( string name, Action<ICodeWriter> content ) {
            return InitializeAccessorBlock( new BlockMember( name, content ) );
        }


        private BlockMember InitializeAccessorBlock( BlockMember block ) {
            block.WriteName = true;
            block.AddGuards( this.AccessorGuards );
            return block;
        }

        private string GetAccessibilityValue( ) {
            return GetAccessibilityValue( this.Accessibility );
        }

        protected static string GetAccessibilityValue( Accessibility accessibility ) {
            return Util.Lowercase( accessibility.ToString( ) );
        }

        private string GetInheritanceValue( ) {
            switch( this.Inheritance ) {
                case Inheritance.Virtual:
                    return " virtual";
                case Inheritance.Override:
                    return " override";
                case Inheritance.New:
                    return " new";
                case Inheritance.None:
                default:
                    return "";
            }
        }

    }

#>
<#+ // ConstantProperty`T.cs

    /// <inheritdoc/>
    /// <summary>
    /// Implements an immutable property that returns a constant value.
    /// </summary>
    public sealed class ConstantProperty<T> : ValueAccessor<T> {

        internal const string DescriptionFormat = "Gets {0}.";


        /// <inheritdoc/>
        protected override IEnumerable<FieldMember> Fields {
            get { return Enumerable.Empty<FieldMember>( ); }
        }

        /// <inheritdoc/>
        protected override IEnumerable<InitializationMember> Initializers {
            get { return Enumerable.Empty<InitializationMember>( ); }
        }

        /// <inheritdoc/>
        protected override AccessorMember Accessor {
            get {
                string defaultValue = this.DefaultValues.Values.Single( );
                return new AccessorMember( this.AccessorName, this.TypeName ) {
                    Doc = this.CreateDoc( )
                        .AddSummary( DescriptionFormat, this.Description ),
                    Modifiers = this.AccessorModifiers,
                    ObserveMember = this.CreateAccessorBlock(
                        ObserveAccessorName,
                        string.Format( "return {0};", defaultValue )
                    )
                };
            }
        }


        /// <inheritdoc/>
        public ConstantProperty( PartialType parent, string name, string description, T value )
            : base( parent, name, description ) {
            this.SetDefaultValue( value );
        }

    }

#>
<#+ // DependencyProperty`T.cs

    /// <inheritdoc/>
    /// <summary>
    /// Implements a dependency property.
    /// </summary>
    public abstract class DependencyProperty<T> : ValueAccessor<T>, FreezableImplementer.ITarget {

        private readonly string changeCallbackName_;
        private readonly string coerceCallbackName_;
        private readonly string validateCallbackName_;

        private readonly string dependencyPropertyTypeName_;
        private readonly string dependencyPropertyKeyTypeName_;

        private Type attachedTargetType_;


        /// <inheritdoc/>
        public override string FieldName { get { return this.AccessorName + MemberKind; } }

        /// <inheritdoc/>
        public override string FieldTypeName { get { return this.dependencyPropertyTypeName_; } }

        /// <inheritdoc/>
        public override string FieldModifiers { get { return GetAccessibilityValue( this.Accessibility ) + " " + this.StandardDependencyPropertyModifiers; } }

        /// <summary>
        /// Gets or sets a value indicating whether this is an attached dependency property.
        /// </summary>
        public bool Attached { get; set; }

        /// <summary>
        /// Gets or sets an attached property's target type. Default is <see cref="UIElement"/>.
        /// </summary>
        public Type AttachedTargetType {
            get { return this.attachedTargetType_ ?? typeof( UIElement ); }
            set {
                Ensure.ArgSatisfies( value == null || typeof( DependencyObject ).IsAssignableFrom( value ), "value", "Target type must derive from DependencyObject: {0}", value );
                this.attachedTargetType_ = value;
            }
        }

        /// <summary>
        /// Gets or sets the accessibility of the dependency property setter accessor.
        /// Any value other than <see cref="Accessibility.Public"/> will create a read-only property.
        /// </summary>
        public Accessibility SetterAccessibility { get; set; }

        /// <summary>
        /// Gets a value indicating whether this is a read-only dependency property.
        /// </summary>
        public bool IsReadOnly { get { return this.SetterAccessibility != Accessibility.Public; } }


        /// <summary>
        /// Gets or sets the options used to construct the dependency property's <see cref="FrameworkPropertyMetadata"/>.
        /// </summary>
        public FrameworkPropertyMetadataOptions Options { get; set; }

        /// <summary>
        /// Gets or sets the change handler to use instead of the <see cref="FrameworkPropertyMetadataOptions"/> compatibility implementation on Silverlight.
        /// </summary>
        public string SilverlightOptionsOverride { get; set; }

        /// <summary>
        /// Gets or sets a value used to determine how the dependency property value is coerced.
        /// </summary>
        public Coerce Coerce { get; set; }

        /// <summary>
        /// Gets or sets a value used to determine how the dependency property value is validated.
        /// </summary>
        public Validate Validate { get; set; }

        /// <summary>
        /// Gets or sets a value used to determine whether a change handler is registered for the dependency property.
        /// </summary>
        public Changed Changed { get; set; }

        /// <summary>
        /// Gets or sets the name of the handler used when <see cref="Coerce"/> is <see cref="Boilen.Coerce.Custom"/>.
        /// </summary>
        public string CoerceHandler { get; set; }

        /// <summary>
        /// Gets or sets the name of the handler used when <see cref="Validate"/> is <see cref="Boilen.Validate.Custom"/>.
        /// </summary>
        public string ValidateHandler { get; set; }

        /// <summary>
        /// Gets or sets the name of the handler used when <see cref="Changed"/> is not <see cref="Boilen.Changed.None"/>.
        /// </summary>
        public string ChangedHandler { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the dependency property is based on an existing dependency property.
        /// </summary>
        internal bool FromExistingProperty { get; set; }


        /// <summary>
        /// Gets the standard modifiers for dependency property fields.
        /// </summary>
        protected string StandardDependencyPropertyModifiers { get { return "static readonly"; } }

        /// <summary>
        /// Gets the suffix for the <see cref="DependencyPropertyKey"/> field, or an empty string if the property is not <see cref="IsReadOnly"/>.
        /// </summary>
        protected string DependencyPropertyKeySuffix { get { return this.IsReadOnly ? "Key" : ""; } }

        /// <summary>
        /// Gets the name of the <see cref="DependencyPropertyKey"/> field, or the <see cref="DependencyProperty"/> field if the property is not <see cref="IsReadOnly"/>.
        /// </summary>
        protected string DependencyPropertyKeyFieldName { get { return this.FieldName + this.DependencyPropertyKeySuffix; } }

        /// <summary>
        /// Gets the field accessor for the <see cref="DependencyProperty"/> object used to observe the property value.
        /// </summary>
        protected string DependencyPropertyObserveName { get { return this.Parent.TypeNamePrefix + "." + this.FieldName; } }

        /// <summary>
        /// Gets the field accessor for the <see cref="DependencyProperty"/> or <see cref="DependencyPropertyKey"/> object used to update the property value.
        /// </summary>
        protected string DependencyPropertyUpdateName { get { return this.DependencyPropertyObserveName + this.DependencyPropertyKeySuffix; } }

        /// <summary>
        /// Gets the name of the shim property changed event handler for dependency properties.
        /// </summary>
        protected string ShimChangedAction { get { return this.ChangedAction + "Shim"; } }

        /// <summary>
        /// Gets the name of the subproperty changed event handler for freezable silverlight dependency properties.
        /// </summary>
        protected string SilverlightSubpropertyChangedAction { get { return this.GetActionName( "SubpropertyChanged" ) + "_SL"; } }

        /// <summary>
        /// Gets the name of the field containing the dependency property value reversion flag used by the freezable silverlight helper.
        /// </summary>
        protected string SilverlightRevertingValueFieldName { get { return Property<bool>.PropertyFieldNamePrefix + this.AccessorName + "_RevertingDependencyPropertyChange_SL"; } }

        /// <summary>
        /// Gets a value indicating whether the declaring type should be considered as freezable in the silverlight implementation.
        /// </summary>
        internal bool IsParentFreezable { get; set; }

        /// <summary>
        /// Gets a value indicating whether the property type should be considered as freezable in the silverlight implementation.
        /// </summary>
        protected bool IsPropertyFreezable {
            get { return !this.Attached && (typeof( Freezable ).IsAssignableFrom( this.Type ) || this.Type.IsInterface); }
        }

        /// <summary>
        /// Gets a value indicating whether a silverlight freezable helper is required.
        /// </summary>
        private bool IsSilverlightPropertyFreezeHelperRequired {
            get { return this.IsPropertyFreezable && !this.Type.Namespace.StartsWith( "System" ); }
        }

        /// <summary>
        /// Gets a value indicating whether a silverlight freezable helper is required.
        /// </summary>
        private bool IsSilverlightStyleFreezeHelperRequired {
            get { return this.IsSilverlightPropertyFreezeHelperRequired && this.Parent.IsStyleable; }
        }

        /// <summary>
        /// Gets a value indicating whether a silverlight freezable helper is required.
        /// </summary>
        protected bool IsSilverlightFreezableHelperRequired {
            get { return this.IsPropertyFreezable && (this.Changed != Changed.None || this.IsParentFreezable); }
        }

        /// <summary>
        /// Gets a value indicating whether a field to flag whether the dependency property value is being reverted is required by the silverlight freezable helper.
        /// </summary>
        protected bool IsSilverlightRevertingValueFieldRequired {
            get { return !this.Attached && (this.Validate != Validate.None || this.IsParentFreezable); }
        }

        /// <summary>
        /// Gets a value indicating whether a <see cref="FrameworkPropertyMetadataOptions"/> value is implemented in a silverlight change helper.
        /// </summary>
        protected bool IsSilverlightMetadataHelperRequired {
            get {
                return !this.Condition.Equals( CompilationSymbol.NotSilverlight )
                    && this.Options != FrameworkPropertyMetadataOptions.None;
            }
        }

        /// <summary>
        /// Gets a value indicating whether a desktop change helper is required.
        /// </summary>
        protected bool IsChangedCallbackShimRequired {
            get {
                return this.Changed != Changed.None
                    && this.Changed != Changed.Static;
            }
        }

        /// <summary>
        /// Gets a value indicating whether a silverlight change helper is required.
        /// </summary>
        protected bool IsSilverlightShimRequired {
            get {
                return this.IsSilverlightMetadataHelperRequired
                    || this.IsParentFreezable
                    || this.IsSilverlightStyleFreezeHelperRequired
                    || this.IsSilverlightFreezableHelperRequired
                    || this.Coerce != Coerce.None
                    || this.Validate != Validate.None;
            }
        }

        /// <summary>
        /// Gets a value indicating whether a silverlight dependency property initializer is required.
        /// </summary>
        protected bool IsSilverlightInitializerRequired {
            get {
                return this.IsSilverlightShimRequired
                    || this.FromExistingProperty
                    || this.IsSilverlightFreezableHelperRequired
                    || this.IsReadOnly
                    || this.Options != FrameworkPropertyMetadataOptions.None
                    || (this.Changed != Changed.None && this.Changed != Changed.Static)
                    || this.DefaultValues.Any( v => v.Key.Equals( CompilationSymbol.Silverlight ) );
            }
        }

        /// <summary>
        /// Gets a value indicating whether changes to the property affect the parent object.
        /// </summary>
        protected bool AffectsParent {
            get { return Flags( FrameworkPropertyMetadataOptions.AffectsParentMeasure ) || Flags( FrameworkPropertyMetadataOptions.AffectsParentArrange ); }
        }


        /// <inheritdoc/>
        protected override IEnumerable<FieldMember> Fields {
            get {
                AttributeMember staticGenericMemberAttribute = this.Parent.Type.IsGenericType
                    ? AttributeMember.SuppressStaticMembersInGenericTypes
                    : AttributeMember.EmptyAttribute;

                if( this.IsReadOnly ) {
                    yield return new FieldMember( this.DependencyPropertyKeyFieldName, this.dependencyPropertyKeyTypeName_ ) {
                        Modifiers = "private " + this.StandardDependencyPropertyModifiers,
                        SpaceOutput = true,
                        Condition = CompilationSymbol.NotSilverlight.Append( this.Condition )
                    };
                    yield return new FieldMember( this.FieldName, this.FieldTypeName ) {
                        Doc = this.CreateFieldDoc( ),
                        Modifiers = this.FieldModifiers,
                        SpaceOutput = true,
                        Condition = CompilationSymbol.NotSilverlight.Append( this.Condition ),
                        Attributes = { staticGenericMemberAttribute }
                    };

                    yield return new FieldMember( this.DependencyPropertyKeyFieldName, this.FieldTypeName ) {
                        Modifiers = "private " + this.StandardDependencyPropertyModifiers,
                        SpaceOutput = true,
                        Condition = CompilationSymbol.Silverlight.Append( this.Condition )
                    };
                    yield return new FieldMember( this.FieldName, this.FieldTypeName ) {
                        Modifiers = "internal " + this.StandardDependencyPropertyModifiers,
                        SpaceOutput = true,
                        Condition = CompilationSymbol.Silverlight.Append( this.Condition )
                    };
                }
                else {
                    yield return new FieldMember( this.FieldName, this.FieldTypeName ) {
                        Doc = this.CreateFieldDoc( ),
                        Modifiers = this.FieldModifiers,
                        SpaceOutput = true,
                        Condition = CompilationSymbol.None,
                        Attributes = { staticGenericMemberAttribute }
                    };
                }
            }
        }

        /// <inheritdoc/>
        protected override AccessorMember Accessor {
            get {
                if( this.Attached )
                    return null;

                var accessor = new AccessorMember( this.AccessorName, this.TypeName ) {
                    Doc = this.CreateAccessorDoc( ),
                    Modifiers = this.AccessorModifiers,
                    ObserveMember = this.CreateAccessorBlock(
                        ObserveAccessorName,
                        string.Format( "return ({0})this.GetValue({1});", this.TypeName, this.DependencyPropertyObserveName ) ),
                    UpdateMember = this.CreateAccessorBlock(
                        (this.SetterAccessibility > this.Accessibility ? GetAccessibilityValue( this.SetterAccessibility ) + " " : "") + UpdateAccessorName,
                        string.Format( "this.SetValue({0}, value);", this.DependencyPropertyUpdateName )
                    )
                };

                if( this.IsSilverlightShimRequired ) {
                    var silverlightArgs = this.BuildRegistrationArguments( true );
                    var silverlightShim = this.CreateChangedCallbackShim( silverlightArgs );
                    accessor.Helpers.Add( silverlightShim );

                    if( this.IsSilverlightFreezableHelperRequired ) {
                        var silverlightFreezableHelper = this.CreateSilverlightFreezableHelper( silverlightArgs.ChangedHandler );
                        accessor.Helpers.Add( silverlightFreezableHelper );
                    }

                    if( this.IsSilverlightRevertingValueFieldRequired ) {
                        string argsType = this.Parent.TypeRepository.GetTypeName( typeof( bool ) );
                        var revertingValueField = new FieldMember( this.SilverlightRevertingValueFieldName, argsType ) { Condition = CompilationSymbol.Silverlight };
                        accessor.Helpers.Add( revertingValueField );
                    }
                }

                if( this.IsChangedCallbackShimRequired ) {
                    var changedCallbackArgs = this.BuildRegistrationArguments( false );
                    var changedCallbackShim = this.CreateChangedCallbackShim( changedCallbackArgs );
                    if( !this.IsSilverlightShimRequired )
                        changedCallbackShim.Condition = CompilationSymbol.None;
                    accessor.Helpers.Add( changedCallbackShim );

                    if( this.Changed == Changed.Virtual ) {
                        var virtualChangedMethod = this.CreateVirtualChangedMethod( );
                        accessor.Helpers.Add( virtualChangedMethod );
                    }
                }

                return accessor;
            }
        }

        /// <summary>
        /// Gets the accessors for an attached dependency property, or an empty enumeration if it is not an attached dependency property.
        /// </summary>
        protected IEnumerable<MethodMember> AttachedAccessors {
            get {
                if( !this.Attached )
                    yield break;

                yield return this.CreateAttachedAccessor( true );
                yield return this.CreateAttachedAccessor( false );

                if( this.IsSilverlightShimRequired ) {
                    var silverlightArgs = this.BuildRegistrationArguments( true );
                    yield return this.CreateChangedCallbackShim( silverlightArgs );
                }

                Ensure.Satisfies( !this.IsChangedCallbackShimRequired, "{0} dependency property changed callbacks are not supported on attached properties.", this.Changed );
            }
        }


        /// <inheritdoc/>
        protected DependencyProperty( PartialType parent, string name, string description )
            : base( parent, name, description ) {
            var typeRepository = this.Parent.TypeRepository;

            this.changeCallbackName_ = typeRepository.GetTypeName( typeof( PropertyChangedCallback ) );
            this.coerceCallbackName_ = typeRepository.GetTypeName( typeof( CoerceValueCallback ) );
            this.validateCallbackName_ = typeRepository.GetTypeName( typeof( ValidateValueCallback ) );

            this.dependencyPropertyTypeName_ = typeRepository.GetTypeName( typeof( DependencyProperty ) );
            this.dependencyPropertyKeyTypeName_ = typeRepository.GetTypeName( typeof( DependencyPropertyKey ) );
        }


        /// <summary>
        /// Assigns the value used for the <see cref="Attached"/> property.
        /// </summary>
        public DependencyProperty<T> SetAttached( bool attached ) {
            this.Attached = attached;
            return this;
        }

        /// <summary>
        /// Assigns the value used for the <see cref="Attached"/> property.
        /// </summary>
        public DependencyProperty<T> SetAttached( Type targetType ) {
            this.AttachedTargetType = targetType;
            this.Attached = targetType != null;
            return this;
        }

        /// <summary>
        /// Assigns the value used for the <see cref="SetterAccessibility"/> property.
        /// </summary>
        [Category( "Read-Only" )]
        public DependencyProperty<T> SetReadOnly( bool readOnly ) {
            Accessibility setterAccessibility = readOnly
                ? Accessibility.Private
                : Accessibility.Public;
            SetSetterAccessibility( setterAccessibility );
            return this;
        }

        /// <summary>
        /// Assigns the value used for the <see cref="SetterAccessibility"/> property.
        /// </summary>
        [Category( "Read-Only" )]
        public DependencyProperty<T> SetSetterAccessibility( Accessibility setterAccessibility ) {
            this.SetterAccessibility = setterAccessibility;
            return this;
        }


        /// <summary>Assigns the valued used for the <see cref="Options"/> property on Desktop and Silverlight.</summary>
        [EditorBrowsable( EditorBrowsableState.Advanced )]
        public DependencyProperty<T> SetOptions( FrameworkPropertyMetadataOptions options, string slOverride ) {
            this.Options = options;
            this.SilverlightOptionsOverride = slOverride;
            return this;
        }

        /// <summary>Assigns the valued used for the <see cref="Options"/> property.</summary>
        [DefaultValue( "None,AffectsMeasure,AffectsArrange,AffectsRender,AffectsParentMeasure,AffectsParentArrange" )]
        public DependencyProperty<T> SetOptions( FrameworkPropertyMetadataOptions options ) { return this.SetOptions( options, null ); }

        /// <summary>Assigns the valued used for the <see cref="Coerce"/> property.</summary>
        public DependencyProperty<T> SetCoerce( Coerce coerce ) { this.Coerce = coerce; return this; }

        /// <summary>Assigns the valued used for the <see cref="Validate"/> property.</summary>
        public virtual DependencyProperty<T> SetValidate( Validate validate ) { this.Validate = validate; return this; }

        /// <summary>Assigns the valued used for the <see cref="Changed"/> property.</summary>
        public DependencyProperty<T> SetChanged( Changed changed ) {
            this.Changed = changed;
            if( this.Changed == Changed.Virtual || this.Changed == Changed.Instance || this.Changed == Changed.Parameterless )
                this.ChangedHandler = "On" + this.ChangedAction;
            return this;
        }

        /// <summary>Assigns the valued used for the <see cref="Coerce"/> property.</summary>
        public DependencyProperty<T> SetCoerce( string coerceHandler ) {
            this.Coerce = Coerce.Custom;
            this.CoerceHandler = coerceHandler;
            return this;
        }

        /// <summary>Assigns the valued used for the <see cref="Validate"/> property.</summary>
        public virtual DependencyProperty<T> SetValidate( string validateHandler ) {
            this.Validate = Validate.Custom;
            this.ValidateHandler = validateHandler;
            return this;
        }

        /// <summary>Assigns the valued used for the <see cref="Changed"/> property.</summary>
        public DependencyProperty<T> SetChanged( string changedHandler ) {
            this.Changed = Changed.Static;
            this.ChangedHandler = changedHandler;
            return this;
        }


        /// <inheritdoc/>
        protected override IEnumerable<Member> GetMembers( ) {
            foreach( var field in this.Fields )
                yield return field;

            foreach( var initializer in this.Initializers )
                yield return initializer;

            var accessor = this.Accessor;
            if( accessor != null ) {
                accessor.AddAttributes( this.Attributes );
                yield return accessor;
            }

            foreach( var attached in this.AttachedAccessors )
                yield return attached;
        }

        /// <inheritdoc/>
        public override void Prepare( ) {
            base.Prepare( );

            if( this.AffectsParent )
                this.Parent.TypeRepository.AddNamespace( typeof( VisualTreeHelper ) );

            if( this.Attached )
                this.Parent.TypeRepository.AddNamespace( this.AttachedTargetType );
        }

        /// <inheritdoc/>
        protected virtual Doc CreateFieldDoc( ) {
            string propertyKind = this.Attached ? "attached" : "dependency";
            string typeFullName = Doc.GetDocTypeName( this.Parent.TypeFullName, false );
            Doc doc = this.CreateDoc( this.FieldName )
                .AddSummary( "Identifies the <see cref='P:{0}.{1}'/> {2} property.", typeFullName, this.AccessorName, propertyKind )
                .AddReturns( "The identifier for the <see cref='P:{0}.{1}'/> {2} property.", typeFullName, this.AccessorName, propertyKind );
            if( this.Attached && this.Description == null )
                doc.UseIncludeTag( ).UseDocMembers( );
            return doc;
        }

        /// <inheritdoc/>
        protected virtual Doc CreateAccessorDoc( ) {
            string settableDescription = this.IsReadOnly ? "Gets {0}." : "Gets or sets {0}.";
            return this.CreateDoc( )
                .AddSummary( settableDescription, this.Description )
                .AddExceptions( this.Guards );
        }

        /// <summary>
        /// Creates arguments for registering a dependency property.
        /// </summary>
        protected DependencyPropertyMetadata BuildRegistrationArguments( bool silverlight ) {
            var args = new DependencyPropertyMetadata( this.Parent.TypeRepository, silverlight );


            // Default value
            string defaultValue = this.GetDefaultValueForMetadata( silverlight );
            args.AddMetadataArgument( defaultValue, DependencyPropertyMetadataKind.Base );

            // Freezable validation
            if( this.IsParentFreezable )
                args.UsedExtensions |= Extensions.Validation;
            if( this.IsSilverlightStyleFreezeHelperRequired || this.IsSilverlightFreezableHelperRequired || defaultValue.Contains( FreezableImplementer.SafeFreezeHelperName ) )
                args.UsedExtensions |= Extensions.Freezable;

            // Meatadata options
            if( !silverlight && this.Options != FrameworkPropertyMetadataOptions.None )
                args.AddMetadataArgument( this.Parent.TypeRepository.GetValueString( this.Options, false ), DependencyPropertyMetadataKind.Framework );


            // Change and Coerce callbacks
            const string CustomCallbackFormat = "new {0}({2}.{1})";
            const string InstanceShimCustomCallbackFormat = "{1}";
            const string SilverlightShimCustomCallbackFormat = "{2}.{1}";

            bool useSilverlightShim = silverlight && this.IsSilverlightShimRequired;
            bool useChangedCallbackShim = this.IsChangedCallbackShimRequired;
            bool useShim = useSilverlightShim || useChangedCallbackShim;
            if( useShim ) {
                string changedCallbackShim = this.CreateCallbackString( CustomCallbackFormat, this.changeCallbackName_, this.ShimChangedAction );
                args.AddMetadataArgument( changedCallbackShim, DependencyPropertyMetadataKind.Base );
            }

            string changedHandlerFormat = null;
            if( useChangedCallbackShim )
                changedHandlerFormat = InstanceShimCustomCallbackFormat;
            else if( this.Changed != Changed.None )
                changedHandlerFormat = useSilverlightShim ? SilverlightShimCustomCallbackFormat : CustomCallbackFormat;
            else if( this.Coerce != Coerce.None )
                changedHandlerFormat = silverlight ? null : "({0})null";
            args.ChangedHandler = this.CreateCallbackString( changedHandlerFormat, this.changeCallbackName_, this.ChangedHandler ?? this.ChangedAction );
            if( !useShim )
                args.AddMetadataArgument( args.ChangedHandler, DependencyPropertyMetadataKind.Base );

            string coerceHandlerFormat = null;
            if( this.Coerce == Coerce.Custom )
                coerceHandlerFormat = silverlight ? SilverlightShimCustomCallbackFormat : CustomCallbackFormat;
            else if( this.Coerce == Coerce.NonNegative ) {
                const string CoerceNonNegative = "DependencyPropertyCallbacks.CoerceNonNegative<{3}>";
                coerceHandlerFormat = silverlight ? CoerceNonNegative : "new {0}(" + CoerceNonNegative + ")";
                args.UsedExtensions |= Extensions.DependencyProperties;
            }
            args.CoerceHandler = this.CreateCallbackString( coerceHandlerFormat, this.coerceCallbackName_, this.CoerceHandler ?? this.CoerceAction );
            if( !silverlight )
                args.AddMetadataArgument( args.CoerceHandler, DependencyPropertyMetadataKind.UI );


            // Validate callback
            string validateHandlerFormat = null;
            if( this.Validate == Validate.Custom )
                validateHandlerFormat = silverlight ? SilverlightShimCustomCallbackFormat : CustomCallbackFormat;
            else if( this.Validate == Validate.Enum ) {
                const string IsValidEnum = "DependencyPropertyCallbacks.IsValidEnum<{3}>";
                validateHandlerFormat = silverlight ? IsValidEnum : "new {0}(" + IsValidEnum + ")";
            }
            else if( this.Validate == Validate.NotNull ) {
                const string IsNotNull = "DependencyPropertyCallbacks.IsNotNull<{3}>";
                validateHandlerFormat = silverlight ? IsNotNull : "new {0}(" + IsNotNull + ")";
            }
            args.ValidationHandler = this.CreateCallbackString( validateHandlerFormat, this.validateCallbackName_, this.ValidateHandler ?? this.ValidateAction );
            if( !string.IsNullOrEmpty( args.ValidationHandler ) ) {
                args.UsedExtensions |= Extensions.DependencyProperties;
                if( silverlight )
                    args.UsedExtensions |= Extensions.Validation;
            }


            return args;
        }

        protected bool InitializeDefaultValueInConstructor( string defaultValue ) {
            // Default values of readonly properties created with "new" will be initialized in constructor instead of metadata.
            return this.IsReadOnly
                && defaultValue != null
                && defaultValue.StartsWith( "new " );
        }


        private bool Flags( FrameworkPropertyMetadataOptions option ) {
            return (this.Options & option) == option;
        }

        private string GetDefaultValueForMetadata( bool silverlight ) {
            string assignedDefaultValue;
            if( !this.DefaultValues.TryGetValue( CompilationSymbol.None, out assignedDefaultValue ) ) {
                var key = silverlight ? CompilationSymbol.Silverlight : CompilationSymbol.NotSilverlight;
                this.DefaultValues.TryGetValue( key, out assignedDefaultValue );
            }

            string metadataDefaultValue;
            if( string.IsNullOrEmpty( assignedDefaultValue ) || this.InitializeDefaultValueInConstructor( assignedDefaultValue ) )
                metadataDefaultValue = "default(" + this.TypeName + ")";
            else {
                if( assignedDefaultValue.StartsWith( "new " ) || assignedDefaultValue.StartsWith( this.TypeName ) )
                    metadataDefaultValue = assignedDefaultValue;
                else
                    metadataDefaultValue = "(" + this.TypeName + ")" + assignedDefaultValue;

                if( silverlight && this.IsSilverlightPropertyFreezeHelperRequired && assignedDefaultValue != "null" && !assignedDefaultValue.Contains( "SafeFreeze(" ) )
                    metadataDefaultValue = "(" + metadataDefaultValue + ").SafeFreeze()";
            }

            return metadataDefaultValue;
        }

        private string CreateCallbackString( string format, string callbackTypeName, string actionName ) {
            if( format == null )
                return null;

            if( actionName.Contains( '.' ) )
                format = format.Replace( "{2}.", "" );

            return string.Format( format, callbackTypeName, actionName, this.Parent.TypeNamePrefix, this.TypeName );
        }

        private MethodMember CreateVirtualChangedMethod( ) {
            var minimumChangedMethod = typeof( System.Windows.Controls.Primitives.RangeBase ).GetMethod( "OnMinimumChanged", BindingFlags.NonPublic | BindingFlags.Instance );
            string documentedMember = minimumChangedMethod.DeclaringType.FullName + ".Minimum";
            string typeNamePrefix = Doc.GetDocTypeName( this.Parent.TypeNamePrefix );
            var parameters = MethodMember.GetParameters( minimumChangedMethod, ( name, type, description ) => {
                var parameter = this.CreateParameter( name.Replace( "Minimum", "Value" ), this.TypeName, description );
                parameter.Doc.AddReplacement( documentedMember, "{0}.{1}", typeNamePrefix, this.AccessorName );
                return parameter;
            } );

            var docMember = XmlDocumentation.GetDocMember( minimumChangedMethod );
            Doc doc = this.CreateDoc( )
                .AddReplacement( documentedMember, "{0}.{1}", typeNamePrefix, this.AccessorName )
                .AddDocElements( XmlDocumentation.FilterElements( docMember, "param" ) );

            var virtualChangedHelper = new MethodMember( this.ChangedHandler, "void", null );
            var virtualChangedCallbackBody = new BlockMember( this.ChangedHandler, w => w.WriteLine( "this.{0}();", this.ChangedHandler ) );
            return new MethodMember( this.ChangedHandler, "void", virtualChangedCallbackBody ) {
                Modifiers = "protected virtual",
                Doc = doc,
                Helpers = { virtualChangedHelper }
            }.AddParameters( parameters );
        }

        private MethodMember CreateChangedCallbackShim( DependencyPropertyMetadata args ) {
            var propertyChangedMethod = typeof( PropertyChangedCallback ).GetMethod( "Invoke" );
            var parameters = MethodMember.GetParameters( propertyChangedMethod, ( name, type, description ) => {
                var parameter = this.CreateParameter( name, type, "empty description of " + name );
                parameter.Doc = null;
                return parameter;
            } ).ToArray( );
            string objectName = parameters[0].Name;
            string changedArgsName = parameters[1].Name;
            string targetName = this.Attached ? objectName : "self";

            var shimPropertyChangedBody = new BlockMember( this.ShimChangedAction, w => {
                bool writeTarget = !this.Attached;
                bool writeCoerce = args.Silverlight && args.CoerceHandler != null;
                bool writeValidate = args.Silverlight && args.ValidationHandler != null;
                bool writeChanged = args.ChangedHandler != null;
                bool writeRevertingValueField = args.Silverlight && this.IsSilverlightRevertingValueFieldRequired;
                bool writeStyleFreezeHelper = args.Silverlight && this.IsSilverlightStyleFreezeHelperRequired;
                bool writeFreezableHelper = args.Silverlight && this.IsSilverlightFreezableHelperRequired;
                bool writeParentFreezableHelpers = args.Silverlight && this.IsParentFreezable;
                bool writeMetadataHelpers = args.Silverlight && this.IsSilverlightMetadataHelperRequired;

                Action revert = ( ) => {
                    if( !this.Attached )
                        w.WriteLine( "{0}.{1} = true;", targetName, this.SilverlightRevertingValueFieldName );
                    w.WriteLine( "{0}.SetValue({1}, {2}.OldValue);", targetName, this.DependencyPropertyUpdateName, changedArgsName );
                    if( !this.Attached )
                        w.WriteLine( "{0}.{1} = false;", targetName, this.SilverlightRevertingValueFieldName );
                };

                Action assignTarget = ( ) =>
                    w.WriteLine( "{0} {1} = ({0}){2};", this.Parent.TypeName, targetName, objectName );
                Action handleRevertingValue = ( ) => {
                    w.WriteLine( "if ({0}.{1})", targetName, this.SilverlightRevertingValueFieldName );
                    using( Enclose.Indent( w ) )
                        w.WriteLine( "return;" );
                };
                Action handleFrozenParent = ( ) => {
                    w.WriteLine( "if ({0}.IsFrozen)", targetName );
                    using( Enclose.Braces( w ) ) {
                        revert( );
                        w.WriteLine( "{0}.GuardValue(\"this\").Satisfies(false, \"Cannot set a property on object '{{0}}' because it is in a read-only state.\", {0});", targetName );
                    }
                };

                Action assignValue = ( ) =>
                    w.WriteLine( "object value = {0}.NewValue;", changedArgsName );
                Action coerce = ( ) => {
                    w.WriteLine( "object coercedValue = {0}({1}, value);", args.CoerceHandler, objectName );
                    w.WriteLine( "if (!object.Equals(coercedValue, value))" );
                    using( Enclose.Braces( w ) ) {
                        w.WriteLine( "{0}.SetValue({1}, coercedValue);", targetName, this.DependencyPropertyUpdateName );
                        w.WriteLine( "return;" );
                    }
                };
                Action validate = ( ) => {
                    w.WriteLine( "bool isValid = {0}(value);", args.ValidationHandler );
                    w.WriteLine( "if (!isValid)" );
                    using( Enclose.Braces( w ) ) {
                        revert( );
                        w.WriteLine( "value.GuardParam(\"value\").Satisfies(false, \"'{{0}}' is not a valid value for property '{0}'.\", value);", this.AccessorName );
                    }
                };

                Action updateStyleFreezeHelpers = ( ) => {
                    w.WriteLine( "object localValue = self.ReadLocalValue({0});", this.FieldName );
                    w.WriteLine( "if (object.ReferenceEquals(localValue, DependencyProperty.UnsetValue))" );
                    using( Enclose.Indent( w ) )
                        w.WriteLine( "{0}.NewValue.SafeFreeze();", changedArgsName );
                };
                Action updateFreezableHelpers = ( ) => {
                    w.WriteLine( "{0}.OldValue.SafeSubpropertyChanged({1}.{2}, false);", changedArgsName, targetName, this.SilverlightSubpropertyChangedAction );
                    w.WriteLine( "{0}.NewValue.SafeSubpropertyChanged({1}.{2}, true);", changedArgsName, targetName, this.SilverlightSubpropertyChangedAction );
                };

                Action changed = ( ) => {
                    if( this.Changed == Changed.Parameterless )
                        w.WriteLine( "{0}.{1}();", targetName, args.ChangedHandler );
                    else if( this.IsChangedCallbackShimRequired )
                        w.WriteLine( "{0}.{1}(({2}){3}.OldValue, ({2}){3}.NewValue);", targetName, args.ChangedHandler, this.TypeName, changedArgsName );
                    else
                        w.WriteLine( "{0}({1}, {2});", args.ChangedHandler, targetName, changedArgsName );
                };
                Action parentFreezableHelpers = ( ) =>
                    w.WriteLine( "{0}.OnSubpropertyChanged();", targetName );
                Action metadataHelpers = ( ) => {
                    if( this.SilverlightOptionsOverride != null )
                        w.WriteLine( "{0}({1}, {2});", this.SilverlightOptionsOverride, targetName, changedArgsName );
                    else
                        this.WriteSilverlightMetadataOptions( w, targetName );
                };


                var body = new[] {
                    new { Write = assignTarget,                 Enable = writeTarget,                   Separate = false },
                    new { Write = handleRevertingValue,         Enable = writeRevertingValueField,      Separate = true  },
                    new { Write = handleFrozenParent,           Enable = writeParentFreezableHelpers,   Separate = true  },
                    new { Write = assignValue,                  Enable = writeCoerce || writeValidate,  Separate = false },
                    new { Write = coerce,                       Enable = writeCoerce,                   Separate = true  },
                    new { Write = validate,                     Enable = writeValidate,                 Separate = true  },
                    new { Write = updateStyleFreezeHelpers,     Enable = writeStyleFreezeHelper,        Separate = true  },
                    new { Write = updateFreezableHelpers,       Enable = writeFreezableHelper,          Separate = true  },
                    new { Write = changed,                      Enable = writeChanged,                  Separate = false },
                    new { Write = parentFreezableHelpers,       Enable = writeParentFreezableHelpers,   Separate = false },
                    new { Write = metadataHelpers,              Enable = writeMetadataHelpers,          Separate = false },
                };

                bool separate = false;
                foreach( var entry in body ) {
                    if( !entry.Enable )
                        continue;

                    if( separate )
                        w.WriteLine( );
                    separate = entry.Separate;

                    entry.Write( );
                }
            } );

            return new MethodMember( this.ShimChangedAction, "void", shimPropertyChangedBody ) {
                Modifiers = "private static",
                Condition = args.Silverlight ? CompilationSymbol.Silverlight : CompilationSymbol.NotSilverlight
            }.AddParameters( parameters );
        }

        private MethodMember CreateSilverlightFreezableHelper( string changedHandler ) {
            var subpropertyChangedMethod = typeof( EventHandler ).GetMethod( "Invoke" );
            var parameters = MethodMember.GetParameters( subpropertyChangedMethod, ( name, type, description ) => {
                var parameter = this.CreateParameter( name, type, "empty description of " + name );
                parameter.Doc = null;
                return parameter;
            } ).ToArray( );

            var silverlightSubpropertyChangedBody = new BlockMember( this.SilverlightSubpropertyChangedAction, w => {
                if( this.Changed == Changed.Parameterless ) {
                    w.WriteLine( "this.{0}();", changedHandler );
                }
                else if( this.IsChangedCallbackShimRequired ) {
                    w.WriteLine( "{0} value = this.{1};", this.TypeName, this.AccessorName );
                    w.WriteLine( "this.{0}(value, value);", changedHandler );
                }
                else if( changedHandler != null ) {
                    w.WriteLine( "{0}(this, null);", changedHandler, typeof( DependencyPropertyChangedEventArgs ).Name );
                }

                if( this.IsParentFreezable )
                    w.WriteLine( "this.OnSubpropertyChanged();" );
            } );

            return new MethodMember( this.SilverlightSubpropertyChangedAction, "void", silverlightSubpropertyChangedBody ) {
                Modifiers = "private",
                Condition = CompilationSymbol.Silverlight
            }.AddParameters( parameters );
        }

        private void WriteSilverlightMetadataOptions( ICodeWriter writer, string targetName ) {
            foreach( FrameworkPropertyMetadataOptions option in Enum.GetValues( typeof( FrameworkPropertyMetadataOptions ) ) ) {
                bool parent = false;
                string methodName = null;

                switch( this.Options & option ) {
                    case FrameworkPropertyMetadataOptions.AffectsParentMeasure: { parent = true; goto case FrameworkPropertyMetadataOptions.AffectsMeasure; }
                    case FrameworkPropertyMetadataOptions.AffectsMeasure: { methodName = "InvalidateMeasure"; break; }

                    case FrameworkPropertyMetadataOptions.AffectsParentArrange: { parent = true; goto case FrameworkPropertyMetadataOptions.AffectsArrange; }
                    case FrameworkPropertyMetadataOptions.AffectsArrange: { methodName = "InvalidateArrange"; break; }

                    case FrameworkPropertyMetadataOptions.AffectsRender: { methodName = "InvalidateRender"; break; }

                    case FrameworkPropertyMetadataOptions.BindsTwoWayByDefault:
                    case FrameworkPropertyMetadataOptions.Inherits:
                    case FrameworkPropertyMetadataOptions.Journal:
                    case FrameworkPropertyMetadataOptions.NotDataBindable:
                    case FrameworkPropertyMetadataOptions.OverridesInheritanceBehavior:
                    case FrameworkPropertyMetadataOptions.SubPropertiesDoNotAffectRender:
                        throw new NotSupportedException( string.Format( "{0} metadata flag value is not supported in silverlight.", option ) );

                    case FrameworkPropertyMetadataOptions.None:
                    default:
                        break;
                }

                if( methodName != null ) {
                    string instance = parent ? "    parent" : this.Attached ? "    target" : targetName;
                    if( parent ) {
                        writer.WriteLine( "UIElement parent = VisualTreeHelper.GetParent({0}) as UIElement;", targetName );
                        writer.WriteLine( "if (!object.ReferenceEquals(parent, null))" );
                    }
                    else if( this.Attached ) {
                        writer.WriteLine( "UIElement target = {0} as UIElement;", targetName );
                        writer.WriteLine( "if (!object.ReferenceEquals(target, null))" );
                    }

                    writer.WriteLine( "{0}.{1}();", instance, methodName );
                }
            }
        }

        private MethodMember CreateAttachedAccessor( bool getAccessor ) {
            string returnType = getAccessor ? this.TypeName : "void";
            string accessorPrefix = getAccessor ? "Get" : "Set";
            string accessorName = accessorPrefix + this.AccessorName;
            string accessibility = (getAccessor || !this.IsReadOnly ? this.AccessorModifiers : GetAccessibilityValue( this.SetterAccessibility )) + " ";

            // Use DockPanel's GetDock/SetDock methods as prototype for attached methods.
            Type dockPanelType = typeof( DockPanel );
            Type dockPropertyType = typeof( Dock );
            string dockPropertyName = dockPropertyType.Name;
            var accessorMember = dockPanelType.GetMethod( accessorPrefix + dockPropertyName );
            var parameters = MethodMember.GetParameters( accessorMember, ( name, type, description ) => {
                if( type == dockPropertyType ) { name = "value"; type = this.Type; }
                else { type = this.AttachedTargetType; }
                var parameter = this.CreateParameter( name, type, description );
                parameter.Doc.AddReplacement( dockPropertyType.FullName + '"', "{0}\"", Doc.GetDocTypeName( this.TypeName ) );
                return parameter;
            } );
            var targetParameter = parameters.First( );
            string targetName = targetParameter.Name;

            // Create the appropriate accessor body.
            string dependencyPropertyName = getAccessor ? this.DependencyPropertyObserveName : this.DependencyPropertyUpdateName;
            string accessorBodyFormat = getAccessor ? "return ({0}){1}.GetValue({2});" : "{1}.SetValue({2}, value);";
            var accessorBody = new BlockMember( accessorName, string.Format( accessorBodyFormat, this.TypeName, targetName, dependencyPropertyName ) );
            accessorBody.AddGuards( new[] { Guard.NotNull( this.CreateDoc( ), targetName, forceDescription: true ) } );

            // Get the prototype documentation.
            var accessorDocMember = XmlDocumentation.GetDocMember( accessorMember );
            Doc doc = this.CreateDoc( )
                .AddReplacement( dockPanelType.FullName + "." + dockPropertyName, "P:{0}.{1}", Doc.GetDocTypeName( this.Parent.TypeFullName, false ), this.AccessorName )
                .AddDocElements( XmlDocumentation.FilterElements( accessorDocMember, "param" ) )
                .UseDocMembers( onlyDocMembers: true );
            if( this.Description != null )
                doc.AddDocElement( "remarks", "{0}s {1}.", accessorPrefix, this.Description );
            return new MethodMember( accessorName, returnType, accessorBody ) {
                Doc = doc,
                Modifiers = accessibility + "static"
            }.AddParameters( parameters );
        }


        #region FreezableImplementer.ITarget Members

        bool FreezableImplementer.ITarget.Freezable {
            get { return this.IsPropertyFreezable; }
        }

        string FreezableImplementer.ITarget.PropertyName {
            get { return this.AccessorName; }
        }

        void FreezableImplementer.ITarget.Prepare( FreezableImplementer implementer ) {
            this.IsParentFreezable = !this.Attached;
        }

        #endregion
    }

#>
<#+ // EquatableInterface.cs

    /// <summary>
    /// Implements the <see cref="IEquatable{T}"/> interface.
    /// </summary>
    public sealed class EquatableInterface : InterfaceImplementer<IEquatable<object>> {

        private static readonly Type InterfaceType = typeof( IEquatable<object> );

        private readonly bool isBaseEquatable_;


        /// <summary>
        /// Gets or sets a value indicating whether to implement the <c>==</c> and <c>!=</c> equality operators.
        /// </summary>
        public bool ImplementOperators { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the type provides a custom <c>Equals</c> method implementation.
        /// </summary>
        public Implementation EqualsImplementation { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the type provides a custom <c>GetHashCode</c> method implementation.
        /// </summary>
        public Implementation GetHashCodeImplementation { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to include an exact type check on the other object.
        /// </summary>
        public bool VerifyExactType { get; set; }

        /// <summary>
        /// Gets or sets a function used to select the format string for comparing or getting the hash code of each equatable property.
        /// </summary>
        /// <remarks>
        /// The second parameter will be <see langword="true"/> for <see cref="EqualsImplementation"/>, and <see langword="false"/> for <see cref="GetHashCodeImplementation"/>.
        /// </remarks>
        public Func<ITarget, bool, string> FormatSelector { get; set; }


        /// <inheritdoc/>
        protected override IEnumerable<Member> InterfaceMembers {
            get {
                var equatableProperties = this.GetTargetData( ( ITarget t ) => t.Equatable, ( ITarget t ) => t );
                Ensure.Satisfies( this.EqualsImplementation.HasFlag( Implementation.Custom ) || equatableProperties.Any( ), "No equatable properties found." );

                // Implement "IEquatable<T>.Equals( T )" interface method.
                yield return this.CreateInterfaceEqualsMethod( equatableProperties );

                // Implement operators, if requested.
                if( this.ImplementOperators ) {
                    yield return this.CreateOperatorMethod( true );
                    yield return this.CreateOperatorMethod( false );
                }

                // Override object equality methods.
                if( this.EqualsImplementation != Implementation.None ) {
                    if( this.isBaseEquatable_ )
                        yield return this.CreateInterfaceEqualsOverride( );
                    else
                        yield return this.CreateObjectEqualsOverride( );
                }

                if( this.GetHashCodeImplementation != Implementation.None ) {
                    yield return this.CreateObjectGetHashCodeOverride( equatableProperties );
                }
            }
        }


        /// <inheritdoc/>
        public EquatableInterface( PartialType parent )
            : base( parent, parent.TypeRepository.GetTypeName( InterfaceType ).Replace( "<object>", "<" + parent.TypeName + ">" ) ) {
            // Ensure all interface types are registered.
            this.Parent.TypeRepository.AddNamespace( typeof( EqualityComparer<> ) );

            Type baseType = this.Parent.BaseType;
            this.isBaseEquatable_ = baseType.GetInterfaces( )
                .Where( i => i.IsGenericType )
                .Select( i => i.GetGenericTypeDefinition( ) )
                .Contains( typeof( IEquatable<> ) );

            this.ImplementOperators = !this.isBaseEquatable_;
            this.EqualsImplementation = Implementation.Auto;
            this.GetHashCodeImplementation = Implementation.Auto;
        }


        /// <inheritdoc/>
        public override void Prepare( ) {
            bool isDependencyObject = typeof( DependencyObject ).IsAssignableFrom( this.Parent.Type );
            Ensure.Satisfies( !isDependencyObject, "Cannot implement IEquatable<T> on type derived from DependencyObject." );

            base.Prepare( );
            this.PrepareTargets( ( ITarget t ) => t.Prepare( this ) );
        }

        /// <summary>
        /// Assigns the values used for the <see cref="ImplementOperators"/> property.
        /// </summary>
        [DefaultValue( "<none>" )]
        public EquatableInterface SetImplementOperators( bool implementOperators ) {
            this.ImplementOperators = implementOperators;
            return this;
        }

        /// <summary>
        /// Assigns the values used for the <see cref="EqualsImplementation"/> property.
        /// </summary>
        [DefaultValue( "Auto,Custom,AutoAndCustom" )]
        public EquatableInterface SetEqualsImplementation( Implementation equalsImplementation ) {
            this.EqualsImplementation = equalsImplementation;
            return this;
        }

        /// <summary>
        /// Assigns the values used for the <see cref="GetHashCodeImplementation"/> property.
        /// </summary>
        [DefaultValue( "Auto,Custom,AutoAndCustom" )]
        public EquatableInterface SetGetHashCodeImplementation( Implementation getHashCodeImplementation ) {
            this.GetHashCodeImplementation = getHashCodeImplementation;
            return this;
        }

        /// <summary>
        /// Assigns the values used for the <see cref="ImplementOperators"/> property.
        /// </summary>
        public EquatableInterface SetVerifyExactType( bool verifyExactType ) {
            this.VerifyExactType = verifyExactType;
            return this;
        }

        /// <summary>
        /// Assigns the values used for the <see cref="FormatSelector"/> property.
        /// </summary>
        public EquatableInterface SetFormatSelector( Func<ITarget, bool, string> formatSelector ) {
            this.FormatSelector = formatSelector;
            return this;
        }


        private MethodMember CreateMethod( string name, string returnType, BlockMember body, XElement existingDoc, string additionalModifiers, params ParameterMember[] parameters ) {
            var method = new MethodMember( name, returnType, body ) {
                Doc = this.CreateDoc( )
            }.AddParameters( parameters );

            if( existingDoc == null )
                method.Doc.InheritFrom = "";
            else
                method.Doc.AddDocElements( XmlDocumentation.FilterElements( existingDoc, "param", "exception" ) );

            if( !string.IsNullOrEmpty( additionalModifiers ) )
                method.Modifiers += " " + additionalModifiers;

            return method;
        }


        private MethodMember CreateInterfaceEqualsMethod( IEnumerable<ITarget> equatableProperties ) {
            var typeRepository = this.Parent.TypeRepository;
            var interfaceEquals = InterfaceType.GetGenericTypeDefinition( ).GetMethod( "Equals" );
            var parameter = MethodMember.GetParameters( interfaceEquals, this.CreateParameter ).Single( );

            string parameterName = parameter.Name;
            string methodName = interfaceEquals.Name;
            string returnType = typeRepository.GetTypeName( interfaceEquals.ReturnType );
            var formatSelector = this.FormatSelector ?? (( p, e ) => null);

            var interfaceEqualsBody = new BlockMember( methodName, w => {
                w.Write( "return " );
                using( Enclose.Indent( w ) ) {
                    if( this.isBaseEquatable_ ) {
                        w.WriteLine( "base.Equals({0})", parameterName );
                        w.Write( "&& " );
                    }
                    else if( !this.Parent.Type.IsValueType ) {
                        w.WriteLine( "!object.ReferenceEquals({0}, null)", parameterName );
                        w.Write( "&& " );
                    }

                    if( this.VerifyExactType && !this.Parent.Type.IsValueType ) {
                        w.WriteLine( "this.GetType() == {0}.GetType()", parameterName );
                        w.Write( "&& " );
                    }

                    var targets = GetTargets( equatableProperties, this.EqualsImplementation );
                    Util.Iterate(
                        targets,
                        ( i, last ) => { w.WriteLine( ); w.Write( "&& " ); },
                        ( i, p ) => {
                            if( p == null ) {
                                w.Write( "this.EqualsCore({0})", parameterName );
                            }
                            else {
                                string format = formatSelector( p, true ) ?? "EqualityComparer<{2}>.Default.Equals(this.{1}, {0}.{1})";
                                w.Write( format, parameterName, p.PropertyName, p.TypeName );
                            }
                        }
                    );

                    w.WriteLine( ";" );
                }
            } );

            string modifiers = this.Parent.IsSealed || this.EqualsImplementation.HasFlag( Implementation.Custom ) ? null : "virtual";
            var interfaceEqualsDoc = XmlDocumentation.GetDocMember( interfaceEquals );
            return this.CreateMethod( methodName, returnType, interfaceEqualsBody, interfaceEqualsDoc, modifiers, parameter );
        }

        private MethodMember CreateInterfaceEqualsOverride( ) {
            var typeRepository = this.Parent.TypeRepository;
            string baseTypeName = this.Parent.BaseTypeName;
            var interfaceEquals = InterfaceType.GetGenericTypeDefinition( ).GetMethod( "Equals" );
            var parameter = MethodMember.GetParameters( interfaceEquals, ( name, type, description ) => new ParameterMember( name, baseTypeName ) ).Single( );

            string parameterName = parameter.Name;
            string methodName = interfaceEquals.Name;
            string returnType = typeRepository.GetTypeName( interfaceEquals.ReturnType );

            var interfaceEqualsBody = new BlockMember( methodName, w => w.WriteLine( "return this.Equals({0} as {1});", parameterName, this.Parent.TypeName ) );
            var method = this.CreateMethod( methodName, returnType, interfaceEqualsBody, null, "override", parameter );
            method.Attributes.Add( AttributeMember.EditorBrowsableNever );
            return method;
        }

        private MethodMember CreateOperatorMethod( bool isEqualityOperator ) {
            const string ReferenceTypeDoc = "%see:parent_type%";
            const string OperatorImplementationFormat = "return {0}EqualityComparer<{2}>.Default.Equals({1});";

            string operatorName = "operator " + (isEqualityOperator ? "==" : "!=");
            string operatorDoc = isEqualityOperator ? "the same value" : "different values";
            string parameterSuffix = this.Parent.Type.IsValueType ? "" : " or null";

            var leftParameter = new ParameterMember( "left", this.Parent.TypeName );
            var rightParameter = new ParameterMember( "right", this.Parent.TypeName );

            string argumentString = leftParameter.Name + ", " + rightParameter.Name;
            var operatorBody = new BlockMember( operatorName, w =>
                w.WriteLine( OperatorImplementationFormat, isEqualityOperator ? "" : "!", argumentString, this.Parent.TypeName )
            );

            var operatorMethod = new MethodMember( operatorName, "bool", operatorBody ) {
                Doc = this.CreateDoc( )
                    .AddSummary( "Determines whether two specified {0} objects have {1}.", ReferenceTypeDoc, operatorDoc )
                    .AddReturns( "true if the value of %paramref:left% is the same as the value of %paramref:right%; otherwise, false." )
                    .AddParam( leftParameter.Name, "A {0} object{1}.", ReferenceTypeDoc, parameterSuffix )
                    .AddParam( rightParameter.Name, "A {0} object{1}.", ReferenceTypeDoc, parameterSuffix ),
                Modifiers = "public static",
                Parameters = { leftParameter, rightParameter }
            };

            return operatorMethod;
        }

        private MethodMember CreateObjectEqualsOverride( ) {
            var objectEqualsMethod = typeof( object ).GetMethod( "Equals", new[] { typeof( object ) } );
            var parameter = MethodMember.GetParameters( objectEqualsMethod, this.CreateParameter ).Single( );

            string parameterName = parameter.Name;
            string typeName = this.Parent.TypeName;
            string methodName = objectEqualsMethod.Name;
            string returnType = this.Parent.TypeRepository.GetTypeName( objectEqualsMethod.ReturnType );

            var objectEqualsBody = new BlockMember( methodName, w => {
                if( this.Parent.Type.IsValueType ) {
                    w.WriteLine( "return {0} is {1}", parameterName, typeName );
                    using( Enclose.Indent( w ) )
                        w.WriteLine( "&& this.Equals(({1}){0});", parameterName, typeName );
                }
                else {
                    w.WriteLine( "return this.Equals({0} as {1});", parameterName, typeName );
                }
            } );

            string modifiers = (this.Parent.Type.IsValueType ? "" : "sealed ") + "override";
            var objectEqualsDoc = XmlDocumentation.GetDocMember( objectEqualsMethod );
            return this.CreateMethod( methodName, returnType, objectEqualsBody, objectEqualsDoc, modifiers, parameter );
        }

        private MethodMember CreateObjectGetHashCodeOverride( IEnumerable<ITarget> equatableProperties ) {
            // http://musingmarc.blogspot.com/2008/03/sometimes-you-make-hash-of-things.html
            var objectGetHashCodeMethod = typeof( object ).GetMethod( "GetHashCode", Type.EmptyTypes );

            string methodName = objectGetHashCodeMethod.Name;
            string returnType = this.Parent.TypeRepository.GetTypeName( objectGetHashCodeMethod.ReturnType );
            var formatSelector = this.FormatSelector ?? (( p, e ) => null);

            var objectGetHashCodeBody = new BlockMember( methodName, w => {
                w.Write( returnType + " hash = " );
                if( this.isBaseEquatable_ ) {
                    w.WriteLine( "base.GetHashCode();" );
                    w.Write( "hash = " );
                }

                var targets = GetTargets( equatableProperties, this.GetHashCodeImplementation );
                Util.Iterate(
                    targets,
                    ( i, last ) => w.Write( "hash = " ),
                    ( i, p ) => {
                        if( this.isBaseEquatable_ || i > 0 )
                            w.Write( "((hash << 5) + hash) ^ " );

                        if( p == null ) {
                            w.Write( "this.GetHashCodeCore()" );
                        }
                        else {
                            string format = formatSelector( p, false ) ?? "EqualityComparer<{1}>.Default.GetHashCode(this.{0})";
                            w.Write( format, p.PropertyName, p.TypeName );
                        }

                        w.WriteLine( ";" );
                    }
                );
                w.WriteLine( "return hash;" );
            } );

            string modifiers = (this.Parent.Type.IsValueType || !this.GetHashCodeImplementation.HasFlag( Implementation.Custom ) ? "" : "sealed ") + "override";
            var objectGetHashCodeDoc = XmlDocumentation.GetDocMember( objectGetHashCodeMethod );
            return this.CreateMethod( methodName, returnType, objectGetHashCodeBody, objectGetHashCodeDoc, modifiers );
        }

        private static IEnumerable<ITarget> GetTargets( IEnumerable<ITarget> equatableProperties, Implementation implementation ) {
            var targets = new List<ITarget>( );

            if( implementation.HasFlag( Implementation.Auto ) )
                targets.AddRange( equatableProperties );

            if( implementation.HasFlag( Implementation.Custom ) )
                targets.Add( null );

            return targets;
        }


        /// <summary>
        /// Represents an <see cref="IImplementer"/> that supports the <see cref="IEquatable{T}"/> interface.
        /// </summary>
        public interface ITarget : IImplementer {
            /// <summary>
            /// Gets a value indicating whether a property should be used when determining the equality of the parent type.
            /// </summary>
            bool Equatable { get; set; }

            /// <summary>
            /// Gets the name of the equatable property represented by the target.
            /// </summary>
            string PropertyName { get; }

            /// <summary>
            /// Called by <see cref="EquatableInterface"/> to prepare a target implementer for the interface.
            /// </summary>
            void Prepare( EquatableInterface implementer );
        }

    }

#>
<#+ // Event`T.cs

    /// <summary>
    /// Implements an event.
    /// </summary>
    /// <typeparam name="T">The type of the event handler.</typeparam>
    public sealed class Event<T> : AccessorImplementer<T> {

        public const string EventFieldNamePrefix = "_privateBackingFieldForEvent_";

        private const string ArgsName = "e";
        private const string EventSummaryPrefix = "Occurs when ";
        private const string HelperSummaryTemplate = "Raises the %see:parent_type.{0}% event.";

        internal const string DescriptionFormat = EventSummaryPrefix + "{0}.";

        /// <summary>The name of the observe accessor for an event.</summary>
        private const string ObserveAccessorName = "add";

        /// <summary>The name of the update accessor for an event.</summary>
        private const string UpdateAccessorName = "remove";

        private readonly Type argsType_;
        private readonly string argsTypeName_;
        private readonly string onHelperName_;
        private readonly AttributeMember onHelperAttribute_;
        private readonly EventInfo existingEvent_;
        private string helperModifiers_;
        private ConstructorInfo argsConstructor_;


        /// <summary>
        /// Gets a value indicating whether a convenience method should be added for creating the event args instance.
        /// </summary>
        public bool EnableArgsConvenienceMethod { get; set; }

        /// <summary>
        /// Gets the <see cref="EventArgs"/> type for the event.
        /// </summary>
        public Type ArgsType { get { return this.argsType_; } }

        /// <summary>
        /// Gets the name of the <see cref="EventArgs"/> type for the event.
        /// </summary>
        public string ArgsTypeName { get { return this.argsTypeName_; } }


        /// <inheritdoc/>
        protected override string FieldNamePrefix { get { return EventFieldNamePrefix; } }

        /// <inheritdoc/>
        protected override bool EnsureDescription {
            get { return base.EnsureDescription && this.existingEvent_ == null; }
        }

        /// <inheritdoc/>
        protected override IEnumerable<InitializationMember> Initializers {
            get { return Enumerable.Empty<InitializationMember>( ); }
        }

        /// <inheritdoc/>
        protected override AccessorMember Accessor {
            get {
                var argsParameter = new ParameterMember( ArgsName, this.ArgsTypeName ) {
                    Doc = new Doc( ArgsName, ArgsName, this.ArgsTypeName, this.TypeName )
                        .AddParam( ArgsName, "An instance of %see:type% that contains the event data." )
                };

                var onEventHelper = CreateOnEventHelper( argsParameter );
                var onConstructorHelper = this.CreateOnConstructorHelper( ) ?? Member.Empty;

                return new AccessorMember( this.AccessorName, this.TypeName ) {
                    Doc = this.CreateDoc( )
                        .AddSummary( DescriptionFormat, this.Description ),
                    Modifiers = this.AccessorModifiers + " event",
                    ObserveMember = this.CreateAccessorBlock(
                        ObserveAccessorName,
                        string.Format( "this.{0} += value;", this.FieldName )
                    ),
                    UpdateMember = this.CreateAccessorBlock(
                        UpdateAccessorName,
                        string.Format( "this.{0} -= value;", this.FieldName )
                    ),
                    Helpers = { onEventHelper, onConstructorHelper }
                };
            }
        }


        /// <inheritdoc/>
        public Event( PartialType parent, string name, string description )
            : base( parent, name, description ) {
            this.EnableArgsConvenienceMethod = true;

            var invokeMethod = typeof( T ).GetMethod( "Invoke" );
            var eventArgsParameter = invokeMethod.GetParameters( ).Skip( 1 ).Single( );

            this.argsType_ = eventArgsParameter.ParameterType;
            this.argsTypeName_ = this.Parent.TypeRepository.GetTypeName( this.argsType_ );
            this.onHelperName_ = "On" + this.AccessorName;
            this.onHelperAttribute_ = AttributeMember.SuppressMessage(
                "Microsoft.Design", "CA1030:UseEventsWhereAppropriate", "Supports the " + this.AccessorName + " event."
            );
        }

        /// <inheritdoc/>
        /// <param name="existingEvent">An existing event to use as a prototype.</param>
        public Event( PartialType parent, EventInfo existingEvent )
            : this( parent, GetExistingEventName( existingEvent ), GetExistingEventDescription( existingEvent ) ) {
            this.existingEvent_ = existingEvent;
        }


        /// <inheritdoc/>
        public override void Prepare( ) {
            base.Prepare( );

            this.Parent.TypeRepository.AddNamespace( typeof( Interlocked ) );

            Accessibility helperAccessibility =
                this.Parent.IsSealed ? Accessibility.Private :
                this.Accessibility == Accessibility.Public ? Accessibility.Protected :
                this.Accessibility;
            this.helperModifiers_ = GetAccessibilityValue( helperAccessibility );

            if( this.EnableArgsConvenienceMethod ) {
                this.argsConstructor_ = this.ArgsType.GetConstructors( )
                    .Where( c => c.GetParameters( ).Length > 0 )
                    .OrderByDescending( c => c.GetParameters( ).Length )
                    .FirstOrDefault( );

                // Ensure all parameter types are registered.
                if( this.argsConstructor_ != null )
                    foreach( var parameter in this.argsConstructor_.GetParameters( ) )
                        this.Parent.TypeRepository.AddNamespace( parameter.ParameterType );
            }
        }

        /// <summary>
        /// Assigns the value used for the <see cref="EnableArgsConvenienceMethod"/> property.
        /// </summary>
        [DefaultValue( "True" )]
        public Event<T> SetEnableArgsConvenienceMethod( bool enable ) {
            this.EnableArgsConvenienceMethod = enable;
            return this;
        }


        // "virtual void On[EventName]([EventArgs] e)" helper
        private MethodMember CreateOnEventHelper( ParameterMember argsParameter ) {
            var onBody = new BlockMember( this.onHelperName_, w => {
                const string HandlerName = "handler";
                w.WriteLine( "{0} {1} = Interlocked.CompareExchange(ref this.{2}, null, null);", this.TypeName, HandlerName, this.FieldName );
                w.WriteLine( "if (!object.ReferenceEquals({0}, null))", HandlerName );
                using( Enclose.Braces( w ) ) { w.WriteLine( "{0}(this, {1});", HandlerName, ArgsName ); }
            } ).AddGuards( new[] { Guard.NotNull( this.CreateDoc( ), ArgsName, forceDescription: true ) } );

            return new MethodMember( this.onHelperName_, "void", onBody ) {
                Modifiers = this.helperModifiers_ + (this.Parent.IsSealed ? "" : " virtual"),
                Doc = this.CreateDoc( this.onHelperName_ )
                    .AddSummary( HelperSummaryTemplate, this.AccessorName )
                    .UseDocMembers( ),
                Parameters = { argsParameter }
            };
        }

        // "void On[EventName]([EventArgs parameters])" helper
        private MethodMember CreateOnConstructorHelper( ) {
            // If method or parameters are undocumented, skip constructor-based helper.
            bool argsAreDocumented = XmlDocumentation.HasXmlDocumentation( this.ArgsType.Assembly );
            if( !argsAreDocumented || this.argsConstructor_ == null )
                return null;

            var parameters = MethodMember.GetParameters(
                this.argsConstructor_,
                ( string name, Type type, string description ) => string.IsNullOrEmpty( description ) ? null : this.CreateParameter( name, type, description )
            );

            if( parameters.Any( p => p == null ) )
                return null;


            // Build constructor-based helper.
            string argsArgumentString = Util.Join( parameters.Select( p => p.Name ), ", " );
            var onConstructorBody = new BlockMember( this.onHelperName_, w => {
                w.WriteLine( "{0} {1} = new {0}({2});", this.ArgsTypeName, ArgsName, argsArgumentString );
                w.WriteLine( "this.On{0}({1});", this.AccessorName, ArgsName );
            } );

            return new MethodMember( this.onHelperName_, "void", onConstructorBody ) {
                Modifiers = this.helperModifiers_,
                Doc = this.CreateDoc( this.onHelperName_ )
                    .AddSummary( HelperSummaryTemplate, this.AccessorName )
                    .UseDocMembers( ),
                Attributes = { this.onHelperAttribute_ }
            }.AddParameters( parameters );
        }


        private static string GetExistingEventName( EventInfo existingEvent ) {
            Ensure.NotNull( existingEvent );

            string eventName = existingEvent.Name;
            string eventImplementerName = char.ToLowerInvariant( eventName[0] ) + eventName.Substring( 1 );
            return eventImplementerName;
        }

        private static string GetExistingEventDescription( EventInfo existingEvent ) {
            Ensure.NotNull( existingEvent );

            string summary = XmlDocumentation.GetSummary( existingEvent );
            Ensure.ArgSatisfies( summary.StartsWith( EventSummaryPrefix ), "existingEvent", "Documentation for event {0} does not begin with expected '{1}' text.", existingEvent.Name, EventSummaryPrefix );

            string description = summary.Substring( EventSummaryPrefix.Length ).TrimEnd( '.' );
            return description;
        }

    }

#>
<#+ // ExistingDependencyProperty`T.cs

    /// <inheritdoc/>
    /// <summary>
    /// Implements an existing dependency property.
    /// </summary>
    public sealed class ExistingDependencyProperty<T> : DependencyProperty<T> {

        private readonly DependencyProperty existingProperty_;
        private readonly string ownerTypeName_;
        private readonly string ownerDocTypeName_;
        private readonly XElement fieldDoc_;
        private readonly XElement accessorDoc_;
        private readonly MethodInfo attachedAccessor_;
        private readonly bool initializing_;

        private NewDependencyProperty<T> silverlightProperty_;


        /// <summary>
        /// Gets the existing dependency property the current property uses.
        /// </summary>
        public DependencyProperty ExistingProperty { get { return this.existingProperty_; } }

        /// <summary>
        /// Gets the type name of the <see cref="DependencyProperty.OwnerType"/> of the existing dependency property.
        /// </summary>
        public string OwnerTypeName { get { return this.ownerTypeName_; } }

        /// <summary>
        /// Gets a value indicating whether we are adding an owner for an attached dependency property.
        /// </summary>
        private bool IsExistingAttached { get { return this.attachedAccessor_ != null; } }


        /// <inheritdoc/>
        protected override IEnumerable<InitializationMember> Initializers {
            get {
                // Ignore validation for building registration arguments.
                var validate = this.Validate;
                this.Validate = Validate.None;
                var wpfArgs = this.BuildRegistrationArguments( false );
                this.Validate = validate;

                yield return new InitializationMember( this.FieldName, w => this.WriteExistingDependencyPropertyInitializer( w, wpfArgs ) ) {
                    MemberScope = this.Parent.TypeNamePrefix,
                    ReferencedExtensions = wpfArgs.UsedExtensions,
                    Condition = CompilationSymbol.NotSilverlight.Append( this.Condition )
                };
            }
        }


        /// <inheritdoc/>
        public ExistingDependencyProperty( PartialType parent, DependencyProperty existingProperty )
            : base( parent, GetDependencyPropertyName( existingProperty ), GetDependencyPropertyDescription( existingProperty ) ) {
            Ensure.ArgTypeMatches<T>( existingProperty.PropertyType );

            this.initializing_ = true;
            this.existingProperty_ = existingProperty;


            // Pull type and documentation info from existing property.
            Type ownerType = existingProperty.OwnerType;
            var typeRepository = this.Parent.TypeRepository;
            this.ownerTypeName_ = typeRepository.GetTypeName( ownerType );
            this.ownerDocTypeName_ = Doc.GetDocTypeName( typeRepository.GetTypeNamespace( ownerType ) + "." + typeRepository.GetTypeName( ownerType ) );
            this.SetReadOnly( existingProperty.ReadOnly );

            this.attachedAccessor_ = ownerType.GetMethod( "Get" + existingProperty.Name );
            if( GlobalSettings.ExternalDocumentationPrefix == null ) {
                var field = GetDependencyPropertyField( existingProperty );
                this.fieldDoc_ = XmlDocumentation.GetDocMember( field );

                if( this.attachedAccessor_ == null ) {
                    var accessor = ownerType.GetProperty( existingProperty.Name );
                    this.accessorDoc_ = XmlDocumentation.GetDocMember( accessor );
                }
                else {
                    this.accessorDoc_ = null;
                }
            }
            else {
                this.fieldDoc_ = null;
                this.accessorDoc_ = null;
            }


            // Pull metadata info from existing property.
            var metadata = this.existingProperty_.DefaultMetadata;
            T defaultValue = (T)metadata.DefaultValue;

            var existingOptions = FrameworkPropertyMetadataOptions.None;
            var frameworkMetadata = metadata as FrameworkPropertyMetadata;
            if( frameworkMetadata != null ) {
                var optionValues = (FrameworkPropertyMetadataOptions[])Enum.GetValues( typeof( FrameworkPropertyMetadataOptions ) );
                var optionAccessors =
                    from value in optionValues
                    let property = typeof( FrameworkPropertyMetadata ).GetProperty( value.ToString( ), typeof( bool ) )
                    where property != null
                    select new { Value = value, Property = property };

                foreach( var oa in optionAccessors ) {
                    bool isSet = (bool)oa.Property.GetValue( frameworkMetadata, null );
                    if( isSet )
                        existingOptions |= oa.Value;
                }
            }

            this.SetDefaultValue( defaultValue );
            this.Options = existingOptions;

            if( metadata.PropertyChangedCallback != null ) {
                this.Changed = Changed.Static;
            }

            if( metadata.CoerceValueCallback != null ) {
                string handler = GetExternalHandler( metadata.CoerceValueCallback.Method );
                if( handler != null )
                    SetCoerce( handler );
                else
                    SetCoerce( Coerce.Custom );
            }

            if( this.existingProperty_.ValidateValueCallback != null ) {
                if( typeof( T ).IsEnum )
                    SetValidate( Validate.Enum );
                else {
                    string handler = GetExternalHandler( this.existingProperty_.ValidateValueCallback.Method );
                    if( handler != null )
                        SetValidate( handler );
                    else
                        SetValidate( Validate.Custom );
                }
            }

            this.initializing_ = false;
        }

        private string GetExternalHandler( MethodInfo method ) {
            if( this.Parent.Type.IsAssignableFrom( method.DeclaringType ) )
                return null;

            string typeName = this.Parent.TypeRepository.GetTypeName( method.DeclaringType );
            string handlerName = typeName + "." + method.Name;

            if( method.IsGenericMethod ) {
                var typeArguments = method.GetGenericArguments( ).Select( this.Parent.TypeRepository.GetTypeName );
                handlerName += "<" + string.Join( ",", typeArguments ) + ">";
            }

            return handlerName;
        }


        /// <inheritdoc/>
        public override DependencyProperty<T> SetValidate( Validate validate ) {
            if( this.initializing_ )
                return base.SetValidate( validate );
            throw new InvalidOperationException( "Cannot change validation of an existing dependency property." );
        }

        /// <inheritdoc/>
        public override void Prepare( ) {
            base.Prepare( );

            if( this.Attached || this.IsReadOnly )
                throw new InvalidOperationException( "Existing Dependency Property cannot be attached, read-only, or use custom validation." );

            if( !this.IsExistingAttached ) {
                // Create new dependency property for silverlight.
                this.silverlightProperty_ = new NewDependencyProperty<T>( this.Parent, this.Name, this.Description ) {
                    Changed = this.Changed,
                    ChangedHandler = this.ChangedHandler,
                    Coerce = this.Coerce,
                    CoerceHandler = this.CoerceHandler,
                    Validate = this.Validate,
                    ValidateHandler = this.ValidateHandler,
                    Options = this.Options,
                    IsParentFreezable = this.IsParentFreezable,
                    FromExistingProperty = true
                };

                foreach( var pair in this.DefaultValues )
                    this.silverlightProperty_.AddDefaultExpression( pair.Key, pair.Value );

                this.silverlightProperty_.Prepare( );
            }
        }


        /// <inheritdoc/>
        protected override IEnumerable<Member> GetMembers( ) {
            var baseMembers = base.GetMembers( );
            var silverlightPropertyMembers =
                this.IsExistingAttached
                    ? new Member[] {
                        new InitializationMember( this.FieldName, this.OwnerTypeName + "." + this.FieldName ) {
                            MemberScope = this.Parent.TypeNamePrefix,
                            Condition = CompilationSymbol.Silverlight.Append( this.Condition )
                        } }
                    : this.silverlightProperty_.Members
                          .Where( m => m.Condition.Equals( CompilationSymbol.Silverlight ) )
                          .Select( m => { m.Condition = m.Condition.Append( this.Condition ); return m; } );

            return baseMembers.Concat( silverlightPropertyMembers );
        }

        /// <inheritdoc/>
        protected override Doc CreateFieldDoc( ) {
            return this.fieldDoc_ == null
                 ? base.CreateFieldDoc( )
                 : this.CreateDependencyPropertyDoc( )
                       .AddDocElements( this.fieldDoc_.Elements( ) );
        }

        /// <inheritdoc/>
        protected override Doc CreateAccessorDoc( ) {
            Doc doc = this.CreateDependencyPropertyDoc( );
            if( GlobalSettings.ExternalDocumentationPrefix != null )
                doc.UseIncludeTag( );
            else if( this.IsExistingAttached )
                doc.InheritFrom = "P:" + this.ownerDocTypeName_ + "." + this.AccessorName;
            else
                doc.AddDocElements( this.accessorDoc_.Elements( ) );

            return doc;
        }

        private Doc CreateDependencyPropertyDoc( ) {
            return this.CreateDoc( )
                .AddReplacement( '"' + this.ExistingProperty.OwnerType.FullName + "." + this.AccessorName + '"', "\"P:{0}.{1}\"", Doc.GetDocTypeName( this.Parent.TypeFullName ), this.AccessorName )
                .AddReplacement( '"' + this.ExistingProperty.OwnerType.FullName, "\"{0}", Doc.GetDocTypeName( this.Parent.TypeName ) );
        }

        private void WriteExistingDependencyPropertyInitializer( ICodeWriter writer, DependencyPropertyMetadata args ) {
            Ensure.ArgSatisfies( !args.Silverlight, "args", "AddOwner only works for non-Silverlight builds." );

            // Check if any metadata changes were made, requiring metadata registration.
            bool requiresMetadata = (args.MetadataKind != DependencyPropertyMetadataKind.Base) || args.ChangedHandler != null;
            if( !requiresMetadata ) {
                var metadata = this.existingProperty_.DefaultMetadata;
                T defaultValue = (T)metadata.DefaultValue;
                string defaultValueString = this.Parent.TypeRepository.GetValueString( defaultValue, false );

                string assignedDefaultValue;
                if( !this.DefaultValues.TryGetValue( CompilationSymbol.None, out assignedDefaultValue ) )
                    assignedDefaultValue = this.DefaultValues[CompilationSymbol.NotSilverlight];

                requiresMetadata = (defaultValueString != assignedDefaultValue);
            }

            writer.Write( "{0}.{1}.AddOwner", this.OwnerTypeName, this.FieldName );
            using( Enclose.Parenthesis( writer ) ) {
                string parentTypeName = string.Format( "typeof({0})", this.Parent.TypeName );
                if( !requiresMetadata )
                    writer.Write( parentTypeName );
                else
                    using( Enclose.NewLine( writer ) )
                    using( Enclose.Indent( writer ) ) {
                        writer.WriteLine( parentTypeName + "," );
                        args.Write( writer );
                    }
            }
        }


        private static FieldInfo GetDependencyPropertyField( DependencyProperty existingProperty ) {
            Ensure.NotNull( existingProperty );
            return existingProperty.OwnerType.GetField( existingProperty.Name + MemberKind );
        }

        private static string GetDependencyPropertyName( DependencyProperty existingProperty ) {
            Ensure.NotNull( existingProperty );
            return existingProperty.Name;
        }

        private static string GetDependencyPropertyDescription( DependencyProperty existingProperty ) {
            if( GlobalSettings.ExternalDocumentationPrefix != null )
                return null;

            var field = GetDependencyPropertyField( existingProperty );
            var summary = XmlDocumentation.GetSummary( field );
            return summary;
        }

    }

#>
<#+ // FreezableImplementer.cs

    /// <summary>
    /// Implements the <see cref="Freezable"/> base class and the user-defined silverlight <c>IFreezable</c> interface.
    /// </summary>
    public sealed class FreezableImplementer : InterfaceImplementer<Freezable> {

        public const string FreezableInterfaceName = "IFreezable";

        public const string SafeFreezeHelperName = "SafeFreeze";

        public const string OnFreezeName = "OnFreeze";

        public const string FreezePropertiesName = "FreezeProperties";

        private const string SubpropertyChangedEventName = "SubpropertyChanged";

        private static readonly AttributeMember EmptyFreezePropertiesBodyAttribute =
            AttributeMember.SuppressMessage( "Microsoft.Performance", "CA1822:MarkMembersAsStatic", "Implemented as part of SL Freezable pattern." );

        private static readonly AttributeMember OnEventAttribute =
            AttributeMember.SuppressMessage( "Microsoft.Design", "CA1030:UseEventsWhereAppropriate", "Supports the SubpropertyChanged event." );


        /// <summary>
        /// Gets or sets a value indicating whether <see cref="Freezable"/> members should be declared or inherited from the base type.
        /// </summary>
        public bool DeclareMembers { get; set; }


        /// <inheritdoc/>
        protected override bool CreateGroup { get { return false; } }

        /// <inheritdoc/>
        protected override IEnumerable<InheritanceMember> ImplementedInterfaces {
            get {
                if( this.DeclareMembers )
                    yield return new InheritanceMember( FreezableInterfaceName, Extensions.Freezable ) {
                        Condition = CompilationSymbol.Silverlight
                    };
            }
        }

        /// <inheritdoc/>
        protected override IEnumerable<Member> InterfaceMembers {
            get {
                var freezablePropertyNames = this.GetTargetData( ( ITarget t ) => t.Freezable, ( ITarget t ) => t.PropertyName );
                var slFreezableMembers = new MemberGroup( FreezableInterfaceName + " Members" ) { Condition = CompilationSymbol.Silverlight };

                // Freezable:
                // protected override Freezable CreateInstanceCore();
                if( !this.Parent.Type.IsAbstract ) {
                    var createInstanceCoreMethod = CreateCreateInstanceCoreMethod( );
                    yield return new MemberGroup( "Freezable Members" ) {
                        Condition = CompilationSymbol.NotSilverlight,
                        Members = { createInstanceCoreMethod }
                    };
                }

                if( this.DeclareMembers ) {
                    // IFreezable:
                    string isFrozenFieldName = Property<bool>.PropertyFieldNamePrefix + "IsFrozen";
                    string isFrozenFieldType = this.Parent.TypeRepository.GetTypeName( typeof( bool ) );
                    string subpropertyChangedFieldName = Event<EventHandler>.EventFieldNamePrefix + SubpropertyChangedEventName;
                    string subpropertyChangedFieldType = this.Parent.TypeRepository.GetTypeName( typeof( EventHandler ) );

                    // public bool IsFrozen { get; }
                    slFreezableMembers.Members.Add( new FieldMember( isFrozenFieldName, isFrozenFieldType ) );
                    slFreezableMembers.Members.Add( this.CreateIsFrozenProperty( isFrozenFieldName ) );

                    // public void Freeze();
                    slFreezableMembers.Members.Add( this.CreateFreezeMethod( isFrozenFieldName, subpropertyChangedFieldName ) );

                    // partial void OnFreeze();
                    slFreezableMembers.Members.Add( this.CreateOnFreezeMethod( ) );

                    // protected virtual FreezeProperties();
                    slFreezableMembers.Members.Add( this.CreateFreezePropertiesMethod( true, freezablePropertyNames ) );

                    // event EventHandler IFreezable.SubpropertyChanged;
                    slFreezableMembers.Members.Add( new FieldMember( subpropertyChangedFieldName, subpropertyChangedFieldType ) );
                    slFreezableMembers.Members.Add( this.CreateSubpropertyChangedEvent( subpropertyChangedFieldName, subpropertyChangedFieldType ) );
                    slFreezableMembers.Members.Add( this.CreateOnSubpropertyChangedMethod( subpropertyChangedFieldName, subpropertyChangedFieldType ) );
                }
                else {
                    // IFreezable:
                    // protected override FreezeProperties();
                    slFreezableMembers.Members.Add( this.CreateFreezePropertiesMethod( false, freezablePropertyNames ) );
                }

                yield return slFreezableMembers;
            }
        }


        /// <inheritdoc/>
        public FreezableImplementer( PartialType parent )
            : base( parent ) { }


        /// <inheritdoc/>
        public override void Prepare( ) {
            base.Prepare( );
            this.PrepareTargets( ( ITarget t ) => t.Prepare( this ) );
        }


        private static IEnumerable<XElement> GetMemberDoc( MemberInfo member ) {
            var memberDoc = XmlDocumentation.GetDocMember( member );
            return XmlDocumentation.FilterElements( memberDoc, "exception" );
        }

        private MethodMember CreateCreateInstanceCoreMethod( ) {
            Doc doc = this.CreateDoc( );
            doc.InheritFrom = "System.Windows.Freezable.CreateInstanceCore";

            var createInstanceCoreBody = new BlockMember( "CreateInstanceCore", w => w.WriteLine( "return new {0}();", this.Parent.TypeName ) );

            var createInstanceCoreMethod = new MethodMember( "CreateInstanceCore", "Freezable", createInstanceCoreBody ) {
                Modifiers = "protected override",
                Doc = doc
            };

            return createInstanceCoreMethod;
        }

        private AccessorMember CreateIsFrozenProperty( string fieldName ) {
            var freezableIsFrozenProperty = typeof( Freezable ).GetProperty( "IsFrozen" );

            string propertyName = freezableIsFrozenProperty.Name;
            string propertyType = this.Parent.TypeRepository.GetTypeName( freezableIsFrozenProperty.PropertyType );

            return new AccessorMember( propertyName, propertyType ) {
                ObserveMember = new BlockMember( "get", string.Format( "return this.{0};", fieldName ) ) { WriteName = true },
                Doc = this.CreateDoc( )
                    .AddDocElements( GetMemberDoc( freezableIsFrozenProperty ) )
            };
        }

        private MethodMember CreateFreezeMethod( string isFrozenFieldName, string subpropertyChangedFieldName ) {
            var freezableFreezeMethod = typeof( Freezable ).GetMethod( "Freeze", Type.EmptyTypes );

            string methodName = freezableFreezeMethod.Name;
            string returnType = this.Parent.TypeRepository.GetTypeName( freezableFreezeMethod.ReturnType );

            var freezeMethodBody = new BlockMember( methodName, w => {
                w.WriteLine( "if (!this.IsFrozen)" );
                using( Enclose.Braces( w ) ) {
                    w.WriteLine( "this.{0}();", OnFreezeName );
                    w.WriteLine( "this.{0}();", FreezePropertiesName );
                    w.WriteLine( "this.{0} = null;", subpropertyChangedFieldName );
                    w.WriteLine( "this.{0} = true;", isFrozenFieldName );
                }
            } );

            return new MethodMember( methodName, returnType, freezeMethodBody ) {
                Doc = this.CreateDoc( )
                    .AddDocElements( GetMemberDoc( freezableFreezeMethod ) )
                    .AddReplacement( "System.Windows.Freezable.", "" )
            };
        }

        private MethodMember CreateOnFreezeMethod( ) {
            return new MethodMember( OnFreezeName, "void", null );
        }

        private MethodMember CreateFreezePropertiesMethod( bool declare, IEnumerable<string> freezableProperties ) {
            string modifiers = declare && this.Parent.IsSealed
                ? "private"
                : "protected " + (declare ? "virtual" : "override");
            string methodName = FreezePropertiesName;
            string returnType = this.Parent.TypeRepository.GetTypeName( typeof( void ) );

            var freezePropertiesMethodBody = new BlockMember( methodName, w => {
                if( !declare )
                    w.WriteLine( "base.{0}();", methodName );

                foreach( string property in freezableProperties ) {
                    w.WriteLine( "this.{0}.{1}();", property, SafeFreezeHelperName );
                }
            } );

            var freezePropertiesMethod = new MethodMember( methodName, returnType, freezePropertiesMethodBody ) {
                Modifiers = modifiers,
                Doc = this.CreateDoc( )
                    .AddSummary( "Calls %see:{0}.Freeze% on every freezable property.", FreezableInterfaceName )
            };

            if( freezableProperties.Any( ) )
                freezePropertiesMethodBody.AddGuards( new[] { Guard.Empty } );
            else if( declare )
                freezePropertiesMethod.AddAttributes( new[] { EmptyFreezePropertiesBodyAttribute } );

            return freezePropertiesMethod;
        }

        private AccessorMember CreateSubpropertyChangedEvent( string fieldName, string fieldType ) {
            string eventName = FreezableInterfaceName + "." + SubpropertyChangedEventName;
            string bodyFormat = "if (!this.IsFrozen) {{ this.{0} {1}= value; }}";
            string addBody = string.Format( bodyFormat, fieldName, "+" );
            string removeBody = string.Format( bodyFormat, fieldName, "-" );

            return new AccessorMember( eventName, fieldType ) {
                Modifiers = "event",
                ObserveMember = new BlockMember( "add", addBody ) { WriteName = true },
                UpdateMember = new BlockMember( "remove", removeBody ) { WriteName = true },
                Doc = this.CreateDoc( )
                    .AddSummary( "Occurs when a property changes." )
            };
        }

        private MethodMember CreateOnSubpropertyChangedMethod( string fieldName, string fieldType ) {
            string onName = "On" + SubpropertyChangedEventName;
            string modifiers = this.Parent.IsSealed ? "private" : "protected";

            var onBody = new BlockMember( onName, w => {
                const string HandlerName = "handler";
                w.WriteLine( "{0} {1} = this.{2};", fieldType, HandlerName, fieldName );
                w.WriteLine( "if (!object.ReferenceEquals({0}, null))", HandlerName );
                using( Enclose.Braces( w ) ) { w.WriteLine( "{0}(this, EventArgs.Empty);", HandlerName ); }
            } );

            return new MethodMember( onName, "void", onBody ) {
                Modifiers = modifiers,
                Doc = this.CreateDoc( )
                   .AddSummary( "Raises the {0} event.", SubpropertyChangedEventName ),
                Attributes = { OnEventAttribute }
            };
        }


        /// <summary>
        /// Represents an <see cref="IImplementer"/> that supports the <see cref="Freezable"/> base class.
        /// </summary>
        public interface ITarget : IImplementer {
            /// <summary>
            /// Gets a value indicating whether a property type is freezable.
            /// </summary>
            bool Freezable { get; }

            /// <summary>
            /// Gets the name of the freezable property represented by the target.
            /// </summary>
            string PropertyName { get; }

            /// <summary>
            /// Called by <see cref="FreezableImplementer"/> to prepare a target implementer for the interface.
            /// </summary>
            void Prepare( FreezableImplementer implementer );
        }

    }

#>
<#+ // IImplementer.cs

    /// <summary>
    /// Implements some aspect of a type, such as a property or an interface implementation.
    /// </summary>
    public interface IImplementer {

        /// <summary>
        /// Gets the parent type of the implementer.
        /// </summary>
        PartialType Parent { get; }

        /// <summary>
        /// Gets the name of the implementer.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Gets the name of the implementer member.
        /// </summary>
        string MemberName { get; }

        /// <summary>
        /// Gets the type of the implementer.
        /// </summary>
        Type Type { get; }

        /// <summary>
        /// Gets the type name of the implementer.
        /// </summary>
        string TypeName { get; }

        /// <summary>
        /// Gets the description of the implementer.
        /// </summary>
        string Description { get; }

        /// <summary>
        /// Gets the implementation members for the implementer.
        /// </summary>
        IEnumerable<Member> Members { get; }

        /// <summary>
        /// Gets the collection of documentation primitives to add to the documentation of each member.
        /// </summary>
        Doc.ReplacementsDictionary Replacements { get; }

        /// <summary>
        /// Gets or sets the conditional compilation symbol for the implementer.
        /// </summary>
        CompilationSymbol Condition { get; set; }


        /// <summary>
        /// Called before a <see cref="PartialType"/> is <see cref="PartialType.Run"/>.
        /// </summary>
        void Prepare( );

    }

#>
<#+ // ImmutableProperty`T.cs

    /// <inheritdoc/>
    /// <summary>
    /// Implements an immutable property.
    /// </summary>
    public sealed class ImmutableProperty<T> : Property<T> {

        internal const string DescriptionFormat = "Gets {0}.";


        /// <summary>
        /// Gets or sets a value indicating whether to include a constructor initializer for the property, or to rely on the default value.
        /// </summary>
        public bool IncludeInConstructor { get; set; }

        /// <inheritdoc/>
        public override string FieldModifiers {
            get { return base.FieldModifiers + " readonly"; }
        }

        /// <inheritdoc/>
        protected override IEnumerable<InitializationMember> Initializers {
            get {
                // Parameter initalizer.
                if( this.IncludeInConstructor )
                    yield return new InitializationMember( this.FieldName, this.FieldTypeName, this.Name ) {
                        Doc = this.CreateDoc( ).AddParam( this.Name, this.Description == null ? null : Util.Capitalize( this.Description ) + "." )
                    }.AddGuards( this.Guards );

                // Default value initializer.
                foreach( var condition in this.DefaultValues.Keys ) {
                    string defaultValue = this.DefaultValues[condition];
                    yield return new InitializationMember( this.FieldName, defaultValue ) { Condition = condition };
                }
            }
        }

        /// <inheritdoc/>
        protected override AccessorMember Accessor {
            get {
                return new AccessorMember( this.AccessorName, this.TypeName ) {
                    Doc = this.CreateDoc( )
                        .AddSummary( DescriptionFormat, this.Description ),
                    Modifiers = this.AccessorModifiers,
                    ObserveMember = this.CreateAccessorBlock(
                        ObserveAccessorName,
                        string.Format( "return this.{0};", this.FieldName )
                    )
                };
            }
        }


        /// <inheritdoc/>
        public ImmutableProperty( PartialType parent, string name, string description )
            : base( parent, name, description ) {
            this.IncludeInConstructor = true;
        }


        /// <summary>
        /// Assigns the value used for the <see cref="IncludeInConstructor"/> property.
        /// </summary>
        [DefaultValue( "True" )]
        public ImmutableProperty<T> SetIncludeInConstructor( bool includeInConstructor ) {
            this.IncludeInConstructor = includeInConstructor;
            return this;
        }

    }

#>
<#+ // Implementer`T.cs

    /// <inheritdoc/>
    public abstract class Implementer<T> : IImplementer {

        private readonly PartialType parent_;
        private readonly string name_;
        private readonly string typeName_;
        private readonly string description_;
        private readonly Doc.ReplacementsDictionary replacements_ = new Doc.ReplacementsDictionary( );

        private Member[] members_;


        /// <inheritdoc/>
        public PartialType Parent { get { return this.parent_; } }

        /// <inheritdoc/>
        public string Name { get { return this.name_; } }

        /// <inheritdoc/>
        public string MemberName { get { return Util.Capitalize( this.Name ); } }

        /// <inheritdoc/>
        public Type Type { get { return typeof( T ); } }

        /// <inheritdoc/>
        public string TypeName { get { return this.typeName_; } }

        /// <inheritdoc/>
        public string Description { get { return this.description_; } }

        /// <inheritdoc/>
        public IEnumerable<Member> Members {
            get {
                if( this.members_ == null )
                    this.members_ = this.GetMembers( )
                        .Where( m => this.Condition.Compatible( m.Condition ) )
                        .Select( m => m.Condition.IsUnconditional ? m.SetCondition( this.Condition ) : m )
                        .ToArray( );
                return this.members_.AsEnumerable( );
            }
        }

        /// <inheritdoc/>
        public Doc.ReplacementsDictionary Replacements { get { return this.replacements_; } }

        /// <inheritdoc/>
        public CompilationSymbol Condition { get; set; }

        /// <summary>Gets a value indicating whether the description parameter should be verified.</summary>
        protected virtual bool EnsureDescription { get { return !this.Parent.IsInternal; } }


        /// <summary>
        /// Initializes a new <see cref="Implementer{T}"/> instance.
        /// </summary>
        /// <param name="parent">The parent of the implementer.</param>
        /// <param name="name">The name of the implementer.</param>
        /// <param name="description">The documentation summary for the implementer.</param>
        protected Implementer( PartialType parent, string name, string description ) {
            Ensure.NotNull( parent );
            Ensure.NotNullOrEmpty( name );

            this.parent_ = parent;
            this.name_ = Util.Lowercase( name );
            this.description_ = description == null ? null : Util.Lowercase( description ).TrimEnd( '.' );
            this.typeName_ = this.Parent.TypeRepository.GetTypeName( typeof( T ) );
        }


        /// <inheritdoc/>
        public virtual void Prepare( ) {
            if( this.EnsureDescription ) {
                if( GlobalSettings.ExternalDocumentationPrefix != null && !string.IsNullOrEmpty( this.description_ ) )
                    throw new InvalidOperationException( "Description on " + this.MemberName + " member on public type cannot be used when specifying external documentation." );
                if( GlobalSettings.ExternalDocumentationPrefix == null && string.IsNullOrEmpty( this.description_ ) )
                    throw new InvalidOperationException( "Description on " + this.MemberName + " member must be specified when not using external documentation." );
            }
        }

        /// <summary>
        /// Assigns the value used for the <see cref="Condition"/> property.
        /// </summary>
        [EditorBrowsable( EditorBrowsableState.Advanced )]
        public Implementer<T> SetCondition( CompilationSymbol condition ) {
            this.Condition = condition;
            return this;
        }

        /// <summary>
        /// Assigns the value used for the <see cref="Condition"/> property.
        /// </summary>
        public Implementer<T> SetCondition( string condition ) {
            this.Condition = new CompilationSymbol( condition );
            return this;
        }


        /// <summary>
        /// Creates the implementation members for the implementer.
        /// </summary>
        protected abstract IEnumerable<Member> GetMembers( );

        /// <summary>
        /// Creates a new <see cref="Doc"/> instance with the appropriate values.
        /// </summary>
        protected Doc CreateDoc( string fullyQualifiedName = null ) {
            return new Doc( fullyQualifiedName ?? this.MemberName, this.Name, this.TypeName, this.Parent.TypeName )
                .AddReplacements( this.Replacements );
        }

        /// <summary>
        /// Creates a <see cref="ParameterMember"/> from a parameter on an existing method.
        /// </summary>
        /// <remarks>
        /// Used with <see cref="MethodMember.GetParameters"/>.
        /// </remarks>
        protected ParameterMember CreateParameter( string name, Type type, string description ) {
            string typeName = type.IsGenericParameter
                ? this.Parent.TypeName
                : this.Parent.TypeRepository.GetTypeName( type );
            return CreateParameter( name, typeName, description );
        }

        /// <summary>
        /// Creates a <see cref="ParameterMember"/> from a parameter on an existing method.
        /// </summary>
        /// <remarks>
        /// Used with <see cref="MethodMember.GetParameters"/>.
        /// </remarks>
        protected ParameterMember CreateParameter( string name, string typeName, string description ) {
            return new ParameterMember( name, typeName ) {
                Doc = this.CreateDoc( ).AddParam( name, description )
            };
        }


        /// <summary>
        /// Ensures the specified implementer is included in the <see cref="Parent"/>'s collection of implementers.
        /// </summary>
        /// <typeparam name="TImplementer">The type of implementer required.</typeparam>
        /// <param name="target">The target compilation symbol.</param>
        /// <param name="creator">A delegate for creating an implementer, if it does not exist.</param>
        /// <returns>The properly configured implementer.</returns>
        protected TImplementer RequireImplementer<TImplementer>( CompilationSymbol target, Action<Action<TImplementer>> creator )
            where TImplementer : class, IImplementer {
            Ensure.NotNull( creator );

            TImplementer[] implementers = this.Parent.Implementers.OfType<TImplementer>( ).ToArray( );

            TImplementer matchingImplementer = implementers.FirstOrDefault( i => i.Condition.Covers( target ) );
            if( matchingImplementer != null ) {
                return matchingImplementer;
            }
            else {
                TImplementer implementer = implementers.FirstOrDefault( );

                if( implementer != null )
                    implementer.Condition = CompilationSymbol.Combine( implementer.Condition, target );
                else
                    creator( i => { implementer = i; implementer.Condition = target; } );

                return implementer;
            }
        }

        /// <summary>
        /// Prepares all <see cref="IImplementer"/> targets for the construct.
        /// </summary>
        /// <typeparam name="TTarget">The type of the implementer target.</typeparam>
        protected void PrepareTargets<TTarget>( Action<TTarget> prepare ) {
            Ensure.NotNull( prepare );

            var targets = this.Parent.Implementers.OfType<TTarget>( );
            foreach( TTarget target in targets )
                prepare( target );
        }

        /// <summary>
        /// Retrieves construct-specific data from all <see cref="IImplementer"/> targets.
        /// </summary>
        /// <typeparam name="TTarget">The type of the implementer target.</typeparam>
        /// <typeparam name="TData">The type of data to retreive from the implementer target.</typeparam>
        protected IEnumerable<TData> GetTargetData<TTarget, TData>( Func<TTarget, bool> filter, Func<TTarget, TData> getData ) {
            Ensure.NotNull( filter, getData );

            return this.Parent.Implementers
                .OfType<TTarget>( )
                .Where( filter )
                .Select( getData );
        }

    }

#>
<#+ // InterfaceImplementer`T.cs

    /// <summary>
    /// Implements an interface or base class, such as INotifyPropertyChanged.
    /// </summary>
    /// <typeparam name="T">The type of the interface.</typeparam>
    public abstract class InterfaceImplementer<T> : Implementer<T> {

        /// <summary>
        /// Gets or sets a value indicating whether <see cref="InterfaceMembers"/> should be automatically wrapped in a group.
        /// </summary>
        protected virtual bool CreateGroup { get { return true; } }

        /// <summary>
        /// Gets the inheritance declarations for all implemented interfaces.
        /// </summary>
        protected virtual IEnumerable<InheritanceMember> ImplementedInterfaces {
            get { yield return new InheritanceMember( this.Name ); }
        }

        /// <summary>
        /// Gets the implementation members for the interface.
        /// </summary>
        protected abstract IEnumerable<Member> InterfaceMembers { get; }

        /// <inheritdoc/>
        protected override bool EnsureDescription { get { return false; } }


        /// <inheritdoc/>
        protected InterfaceImplementer( PartialType parent, string name )
            : base( parent, name, XmlDocumentation.GetSummary( typeof( T ) ) ) { }

        /// <inheritdoc/>
        protected InterfaceImplementer( PartialType parent )
            : this( parent, parent.TypeRepository.GetTypeName( typeof( T ) ) ) { }


        /// <inheritdoc/>
        protected sealed override IEnumerable<Member> GetMembers( ) {
            foreach( var inherit in this.ImplementedInterfaces )
                yield return inherit;

            var group = new MemberGroup( this.Name + " Members" );
            foreach( var member in this.InterfaceMembers ) {
                if( this.CreateGroup )
                    group.Members.Add( member );
                else
                    yield return member;
            }

            if( this.CreateGroup )
                yield return group;
        }

    }

#>
<#+ // LazyProperty`T.cs

    /// <inheritdoc/>
    /// <summary>
    /// Implements a lazy property.
    /// </summary>
    public sealed class LazyProperty<T> : MutableProperty<T>
        where T : class {


        /// <summary>
        /// Gets the expression used to initialize the property.
        /// </summary>
        public string InitializerExpression { get; private set; }

        /// <inheritdoc/>
        protected override string FieldNamePrefix { get { return Property<T>.PropertyFieldNamePrefix; } }

        /// <inheritdoc/>
        protected override IEnumerable<InitializationMember> Initializers {
            get { yield break; }
        }

        /// <inheritdoc/>
        protected override AccessorMember Accessor {
            get {
                var accessor = base.Accessor;
                accessor.ObserveMember = this.CreateAccessorBlock( ObserveAccessorName, WriteAccessorBlock );
                return accessor;
            }
        }


        /// <inheritdoc/>
        public LazyProperty( PartialType parent, string name, string description, string initializerExpression )
            : base( parent, name, description ) {
            this.InitializerExpression = initializerExpression;
        }


        private void WriteAccessorBlock( ICodeWriter writer ) {
            writer.WriteLine( "if (object.ReferenceEquals(this.{0}, null))", this.FieldName );
            using( Enclose.Braces( writer ) )
                writer.WriteLine( "this.{0} = {1};", this.AccessorName, this.InitializerExpression );

            writer.WriteLine( );
            writer.WriteLine( "return this.{0};", this.FieldName );
        }

    }

#>
<#+ // MetadataOverride`T.cs

    /// <inheritdoc/>
    /// <summary>
    /// Implements a dependency property metadata override.
    /// </summary>
    public sealed class MetadataOverride<T> : ValueAccessor<T> {

        private readonly string ownerTypeName_;
        private readonly bool isInherited_;


        /// <inheritdoc/>
        public override string FieldName { get { return this.AccessorName + MemberKind; } }

        /// <inheritdoc/>
        public override string FieldTypeName { get { return this.ownerTypeName_; } }

        /// <inheritdoc/>
        public override string FieldModifiers { get { return ""; } }

        /// <summary>
        /// Gets or sets a value indicating whether the metadata should be overridden in silverlight as well as WPF.
        /// </summary>
        public bool OverrideInSilverlight { get; set; }


        /// <inheritdoc/>
        protected override IEnumerable<InitializationMember> Initializers {
            get {
                var wpfArgs = this.BuildRegistrationArguments( false );
                yield return new InitializationMember( this.AccessorName, w => this.WriteMetadataOverride( w, wpfArgs ) ) {
                    Condition = CompilationSymbol.NotSilverlight,
                    MemberScope = FieldTypeName,
                    WriteVariableAssignment = false
                };

                if( this.OverrideInSilverlight ) {
                    string defaultValue = GetDefaultValueString( true );
                    var silverlightInitializer = this.isInherited_
                        ? new InitializationMember( this.AccessorName, defaultValue )
                        : new InitializationMember( this.AccessorName, string.Format( "{0}.Set{1}(this, {2})", this.ownerTypeName_, this.AccessorName, defaultValue ) ) { WriteVariableAssignment = false };
                    silverlightInitializer.Condition = CompilationSymbol.Silverlight;
                    yield return silverlightInitializer;
                }
            }
        }

        /// <inheritdoc/>
        protected override AccessorMember Accessor {
            get { return null; }
        }

        /// <inheritdoc/>
        protected override bool EnsureDescription {
            get { return false; }
        }


        /// <inheritdoc/>
        public MetadataOverride( PartialType parent, DependencyProperty existingProperty, Type ownerType )
            : base( parent, existingProperty.Name, " " ) {
            Ensure.ArgTypeMatches<T>( existingProperty.PropertyType );

            this.ownerTypeName_ = this.Parent.TypeRepository.GetTypeName( ownerType );

            Type parentType = this.Parent.BaseType;
            this.isInherited_ = ownerType.IsAssignableFrom( parentType )
                || parentType.GetProperties( BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance )
                    .Any( p => p.Name == this.AccessorName && p.PropertyType == this.Type );

            this.OverrideInSilverlight = true;
        }

        /// <inheritdoc/>
        public MetadataOverride( PartialType parent, DependencyProperty existingProperty )
            : this( parent, existingProperty, existingProperty.OwnerType ) { }


        /// <summary>
        /// Assigns the values used for the <see cref="OverrideInSilverlight"/> property.
        /// </summary>
        [DefaultValue( "True" )]
        public MetadataOverride<T> SetOverrideInSilverlight( bool overrideInSilverlight ) {
            this.OverrideInSilverlight = overrideInSilverlight;
            return this;
        }


        /// <inheritdoc/>
        protected override IEnumerable<Member> GetMembers( ) {
            foreach( var initializer in this.Initializers )
                yield return initializer;
        }


        /// <summary>
        /// Creates arguments for registering a dependency property.
        /// </summary>
        private DependencyPropertyMetadata BuildRegistrationArguments( bool silverlight ) {
            var args = new DependencyPropertyMetadata( this.Parent.TypeRepository, silverlight ) { InlineSingleArgument = true };

            // Default value
            string defaultValue = this.GetDefaultValueString( silverlight );
            args.AddMetadataArgument( defaultValue, DependencyPropertyMetadataKind.Framework );

            return args;
        }


        private string GetDefaultValueString( bool silverlight ) {
            string assignedDefaultValue;
            if( !this.DefaultValues.TryGetValue( CompilationSymbol.None, out assignedDefaultValue ) ) {
                var key = silverlight ? CompilationSymbol.Silverlight : CompilationSymbol.NotSilverlight;
                this.DefaultValues.TryGetValue( key, out assignedDefaultValue );
            }

            string defaultValue;
            if( string.IsNullOrEmpty( assignedDefaultValue ) )
                defaultValue = "default(" + this.TypeName + ")";
            else if( assignedDefaultValue.StartsWith( "new " ) || assignedDefaultValue.StartsWith( this.TypeName ) || typeof( T ) == typeof( object ) )
                defaultValue = assignedDefaultValue;
            else
                defaultValue = "(" + this.TypeName + ")" + assignedDefaultValue;

            return defaultValue;
        }

        private void WriteMetadataOverride( ICodeWriter writer, DependencyPropertyMetadata args ) {
            writer.Write( "{0}.{1}.OverrideMetadata", this.ownerTypeName_, this.FieldName );
            using( Enclose.Parenthesis( writer ) ) {
                writer.Write( "typeof({0}), ", this.Parent.TypeName );
                args.Write( writer );
            }
        }
    }

#>
<#+ // MutableProperty`T.cs

    /// <inheritdoc/>
    /// <summary>
    /// Implements a mutable property.
    /// </summary>
    public class MutableProperty<T> : Property<T>, PropertyNameConstants.ITarget, NotifyPropertyChangedInterface.ITarget {

        internal const string DescriptionFormat = "Gets or sets {0}.";


        /// <summary>
        /// Gets or sets the accessibility of the property setter accessor.
        /// Any value other than <see cref="Accessibility.Public"/> will create a read-only property.
        /// </summary>
        public Accessibility SetterAccessibility { get; set; }

        /// <summary>
        /// Gets or sets the format used to compare the current and assigned values in the property setter accessor,
        ///  or null to disable equality checking.
        /// </summary>
        public string EqualityFormat { get; set; }


        /// <inheritdoc/>
        protected override IEnumerable<InitializationMember> Initializers {
            get {
                // Default value initializer.
                foreach( var condition in this.DefaultValues.Keys ) {
                    string defaultValue = this.DefaultValues[condition];
                    yield return new InitializationMember( this.FieldName, defaultValue ) { Condition = condition };
                }
            }
        }

        /// <inheritdoc/>
        protected override AccessorMember Accessor {
            get {
                var coerceHelper = new MethodMember( this.CoerceAction, "void", null ) { Parameters = { new ParameterMember( "value", "ref " + this.FieldTypeName ) }, Attributes = { AttributeMember.SuppressUnusedPartialParameters } };
                var changingHelper = new MethodMember( this.ChangingAction, "void", null ) { Parameters = { new ParameterMember( "newValue", this.FieldTypeName ) }, Attributes = { AttributeMember.SuppressUnusedPartialParameters } };
                var changedHelper = new MethodMember( this.ChangedAction, "void", null ) { Parameters = { new ParameterMember( "oldValue", this.FieldTypeName ) }, Attributes = { AttributeMember.SuppressUnusedPartialParameters } };

                bool isExternallyReadOnly = this.SetterAccessibility > this.Accessibility;
                string updateAccessibility = isExternallyReadOnly ? GetAccessibilityValue( this.SetterAccessibility ) + " " : "";
                var updateBlock = this.CreateAccessorBlock( updateAccessibility + UpdateAccessorName, this.WriteAssignmentBody );
                updateBlock.PreContent = w => w.WriteLine( "this.{0}(ref value);", this.CoerceAction );
                updateBlock.AddGuards( Guard.ChangeValueName( this.Guards, "value" ) );

                return new AccessorMember( this.AccessorName, this.TypeName ) {
                    Doc = this.CreateDoc( )
                        .AddSummary( isExternallyReadOnly ? ImmutableProperty<T>.DescriptionFormat : DescriptionFormat, this.Description ),
                    Modifiers = this.AccessorModifiers,
                    ObserveMember = this.CreateAccessorBlock(
                        ObserveAccessorName,
                        string.Format( "return this.{0};", this.FieldName )
                    ),
                    UpdateMember = updateBlock,
                    Helpers = { coerceHelper, changingHelper, changedHelper }
                };
            }
        }


        /// <inheritdoc/>
        public MutableProperty( PartialType parent, string name, string description )
            : base( parent, name, description ) {
            this.EqualityFormat = "EqualityComparer<{0}>.Default.Equals(this.{1}, value)";
        }


        /// <summary>
        /// Assigns the value used for the <see cref="SetterAccessibility"/> property.
        /// </summary>
        public MutableProperty<T> SetSetterAccessibility( Accessibility setterAccessibility ) {
            this.SetterAccessibility = setterAccessibility;
            return this;
        }

        /// <summary>
        /// Assigns the value used for the <see cref="EqualityFormat"/> property.
        /// </summary>
        [DefaultValue( "EqualityComparer<{0}>.Default.Equals(this.{1}, value)" )]
        public MutableProperty<T> SetEqualityFormat( string equalityFormat ) {
            this.EqualityFormat = equalityFormat;
            return this;
        }

        public override void Prepare( ) {
            base.Prepare( );

            // Ensure EqualityComparer type is registered, if needed.
            if( !string.IsNullOrEmpty( this.EqualityFormat ) )
                this.Parent.TypeRepository.AddNamespace( typeof( EqualityComparer<> ) );
        }


        private void WriteAssignmentBody( ICodeWriter writer ) {
            if( string.IsNullOrEmpty( this.EqualityFormat ) ) {
                this.WriteAssignmentInnerBody( writer );
            }
            else {
                writer.WriteLine( "if (!" + this.EqualityFormat + ")", this.TypeName, this.FieldName );
                using( Enclose.Braces( writer ) )
                    this.WriteAssignmentInnerBody( writer );
            }
        }

        private void WriteAssignmentInnerBody( ICodeWriter writer ) {
            writer.WriteLine( "this.{0}(value);", this.ChangingAction );
            writer.WriteLine( "{0} oldValue = this.{1};", this.FieldTypeName, this.FieldName );
            writer.WriteLine( "this.{0} = value;", this.FieldName );
            writer.Write( "this.{0}(oldValue);", this.ChangedAction );

            if( this.ImplementINotifyPropertyChanged ) {
                var conditioanlSymbols = this.conditionalINotifyPropertyChanged_
                    .Where( c => !c.IsUnconditional )
                    .Select( c => c.Symbol );
                string condition = Util.Join( conditioanlSymbols, " || " );
                bool hasCondition = !string.IsNullOrEmpty( condition );
                string onCall = string.Format( "this.OnPropertyChanged({0}{1});", this.AccessorName, PropertyNameConstants.PropertyNameSuffix );

                if( hasCondition ) {
                    writer.WriteLineUnindented( "#if {0}", condition );
                    writer.Write( onCall );
                    writer.WriteLineUnindented( "#endif" );
                }
                else {
                    writer.WriteLine( );
                    writer.WriteLine( onCall );
                }
            }
            else {
                writer.WriteLine( );
            }
        }


        #region PropertyNameConstants.ITarget Members

        /// <inheritdoc/>
        bool PropertyNameConstants.ITarget.ShouldCreateConstant {
            get { return true; }
        }

        /// <inheritdoc/>
        string PropertyNameConstants.ITarget.PropertyName {
            get { return this.AccessorName; }
        }

        /// <inheritdoc/>
        string PropertyNameConstants.ITarget.Accessibility {
            get { return GetAccessibilityValue( this.Accessibility ); }
        }

        /// <inheritdoc/>
        void PropertyNameConstants.ITarget.Prepare( PropertyNameConstants implementer ) { }

        #endregion

        #region NotifyPropertyChangedInterface.ITarget Members

        private readonly List<CompilationSymbol> conditionalINotifyPropertyChanged_ = new List<CompilationSymbol>( );

        private bool ImplementINotifyPropertyChanged { get { return this.conditionalINotifyPropertyChanged_.Any( ); } }

        /// <inheritdoc/>
        bool NotifyPropertyChangedInterface.ITarget.ShouldNotify {
            get { return true; }
        }

        /// <inheritdoc/>
        void NotifyPropertyChangedInterface.ITarget.Prepare( NotifyPropertyChangedInterface implementer ) {
            this.conditionalINotifyPropertyChanged_.Add( implementer.Condition );
        }

        #endregion

    }

#>
<#+ // NewDependencyProperty`T.cs

    /// <inheritdoc/>
    /// <summary>
    /// Implements a new dependency property.
    /// </summary>
    public sealed class NewDependencyProperty<T> : DependencyProperty<T> {

        /// <inheritdoc/>
        protected override IEnumerable<InitializationMember> Initializers {
            get {
                // Add constructor initializer for dependency property default values, as needed.
                foreach( var pair in this.DefaultValues )
                    if( this.InitializeDefaultValueInConstructor( pair.Value ) )
                        yield return new InitializationMember( this.AccessorName, pair.Value ) { Condition = pair.Key };

                // Add static initializers for dependency property fields.
                string initializerScope = this.Parent.TypeNamePrefix;

                var wpfArgs = this.BuildRegistrationArguments( false );
                var wpfCondition = this.IsSilverlightInitializerRequired ? CompilationSymbol.NotSilverlight.Append( this.Condition ) : CompilationSymbol.None;
                yield return new InitializationMember( this.DependencyPropertyKeyFieldName, w => this.WriteNewDependencyPropertyInitializer( w, wpfArgs ) ) {
                    MemberScope = initializerScope,
                    Condition = wpfCondition,
                    ReferencedExtensions = wpfArgs.UsedExtensions,
                    DependentInitializer = this.IsReadOnly
                        ? new InitializationMember( this.FieldName, this.DependencyPropertyKeyFieldName + "." + this.FieldTypeName ) { MemberScope = initializerScope, Condition = wpfCondition }
                        : null
                };

                var silverlightArgs = this.BuildRegistrationArguments( true );
                if( this.IsSilverlightInitializerRequired )
                    yield return new InitializationMember( this.DependencyPropertyKeyFieldName, w => this.WriteNewDependencyPropertyInitializer( w, silverlightArgs ) ) {
                        MemberScope = initializerScope,
                        Condition = CompilationSymbol.Silverlight.Append( this.Condition ),
                        ReferencedExtensions = silverlightArgs.UsedExtensions,
                        DependentInitializer = this.IsReadOnly
                            ? new InitializationMember( this.FieldName, this.DependencyPropertyKeyFieldName ) { MemberScope = initializerScope, Condition = CompilationSymbol.Silverlight }
                            : null
                    };
            }
        }


        /// <inheritdoc/>
        public NewDependencyProperty( PartialType parent, string name, string description )
            : base( parent, name, description ) { }


        private void WriteNewDependencyPropertyInitializer( ICodeWriter writer, DependencyPropertyMetadata args ) {
            string registerAttached = this.Attached ? "Attached" : "";
            string registerReadOnly = !args.Silverlight && this.IsReadOnly ? "ReadOnly" : "";

            writer.Write( "{0}.Register{1}{2}", this.FieldTypeName, registerAttached, registerReadOnly );
            using( Enclose.Parenthesis( writer ) )
            using( Enclose.NewLine( writer ) )
            using( Enclose.Indent( writer ) ) {
                writer.WriteLine( "\"{0}\", typeof({1}), typeof({2}),", this.AccessorName, this.TypeName, this.Parent.TypeName );
                args.Write( writer );
            }
        }

    }

#>
<#+ // NotifyPropertyChangedInterface.cs

    /// <summary>
    /// Implements the <see cref="INotifyPropertyChanged"/> interface.
    /// </summary>
    public sealed class NotifyPropertyChangedInterface : InterfaceImplementer<INotifyPropertyChanged> {

        /// <summary>
        /// Gets or sets a value indicating whether to use the implementation defined on the base class.
        /// </summary>
        public bool InheritImplementation { get; set; }


        /// <inheritdoc/>
        protected override IEnumerable<Member> InterfaceMembers {
            get {
                // "PropertyChanged" event.
                Type baseType = this.Parent.Type.BaseType;
                bool baseImplementsInterface = typeof( INotifyPropertyChanged ).IsAssignableFrom( baseType );
                if( !baseImplementsInterface && !this.InheritImplementation ) {
                    var existingEvent = typeof( INotifyPropertyChanged ).GetEvent( "PropertyChanged" );
                    var propertyChangedEvent = new Event<PropertyChangedEventHandler>( this.Parent, existingEvent );
                    propertyChangedEvent.Prepare( );
                    foreach( var eventMember in propertyChangedEvent.Members )
                        yield return eventMember;
                }
            }
        }


        /// <inheritdoc/>
        public NotifyPropertyChangedInterface( PartialType parent )
            : base( parent ) { }


        /// <inheritdoc/>
        public override void Prepare( ) {
            base.Prepare( );

            // Add PropertyNameConstants implementation, if one is not already defined.
            this.RequireImplementer<PropertyNameConstants>( this.Condition, c => this.Parent.ImplementPropertyNameConstants( c ) );

            this.PrepareTargets( ( ITarget t ) => t.Prepare( this ) );
        }

        /// <summary>
        /// Assigns the values used for the <see cref="InheritImplementation"/> property.
        /// </summary>
        public NotifyPropertyChangedInterface SetInheritImplementation( bool inheritImplementation ) {
            this.InheritImplementation = inheritImplementation;
            return this;
        }


        /// <summary>
        /// Represents an <see cref="IImplementer"/> that supports the <see cref="INotifyPropertyChanged"/> interface.
        /// </summary>
        public interface ITarget : IImplementer {
            /// <summary>
            /// Gets a value indicating whether the property should cause a change notification.
            /// </summary>
            bool ShouldNotify { get; }

            /// <summary>
            /// Called by <see cref="NotifyPropertyChangedInterface"/> to prepare a target implementer for the interface.
            /// </summary>
            void Prepare( NotifyPropertyChangedInterface implementer );
        }

    }

#>
<#+ // PropertyNameConstants.cs

    /// <summary>
    /// Implements string constants for property names.
    /// </summary>
    public sealed class PropertyNameConstants : Implementer<string> {

        /// <summary>The suffix used for property name constants.</summary>
        public const string PropertyNameSuffix = "PropertyName";


        /// <inheritdoc/>
        protected override bool EnsureDescription { get { return false; } }


        /// <inheritdoc/>
        public PropertyNameConstants( PartialType parent )
            : base( parent, "PropertyNameConstants", PropertyNameSuffix ) { }


        /// <inheritdoc/>
        public override void Prepare( ) {
            base.Prepare( );
            this.PrepareTargets( ( ITarget t ) => t.Prepare( this ) );
        }


        /// <inheritdoc/>
        protected override IEnumerable<Member> GetMembers( ) {
            var group = new MemberGroup( "Property Names" ) { Condition = this.Condition };

            var namedProperties = this.GetTargetData( ( ITarget t ) => t.ShouldCreateConstant, ( ITarget t ) => new { t.PropertyName, t.Accessibility } );
            foreach( var namedProperty in namedProperties )
                group.Members.Add( this.CreateConstant( namedProperty.PropertyName, namedProperty.Accessibility ) );

            yield return group;
        }


        private ConstantMember CreateConstant( string propertyName, string accessibility ) {
            var constant = new ConstantMember( propertyName + PropertyNameSuffix, this.TypeName, '"' + propertyName + '"' ) {
                Modifiers = accessibility + " const",
                Doc = this.CreateDoc( )
                    .AddSummary( "The name of the %see:parent_type.{0}% property.", propertyName )
            };

            if( this.Parent.Type.IsGenericType )
                constant.Attributes.Add( AttributeMember.SuppressStaticMembersInGenericTypes );

            return constant;
        }


        /// <summary>
        /// Represents an <see cref="IImplementer"/> that supports the <see cref="PropertyNameConstants"/> construct.
        /// </summary>
        public interface ITarget : IImplementer {
            /// <summary>
            /// Gets a value indicating whether the property needs a constant property name value.
            /// </summary>
            bool ShouldCreateConstant { get; }

            /// <summary>
            /// Gets the name of the property represented by the target.
            /// </summary>
            string PropertyName { get; }

            /// <summary>
            /// Gets the accessibility of the property represented by the target.
            /// </summary>
            string Accessibility { get; }

            /// <summary>
            /// Called by <see cref="PropertyNameConstants"/> to prepare a target implementer.
            /// </summary>
            void Prepare( PropertyNameConstants implementer );
        }

    }

#>
<#+ // Property`T.cs

    /// <summary>
    /// Implements a property.
    /// </summary>
    /// <typeparam name="T">The type of the property.</typeparam>
    public abstract class Property<T> : ValueAccessor<T> {

        /// <inheritdoc/>
        protected Property( PartialType parent, string name, string description )
            : base( parent, name, description ) {
        }


        #region Standard Guards

        /// <summary>
        /// Ensures the assigned property value is not <null/>.
        /// </summary>
        public Property<T> NotNull( Action<Guard> configure = null ) {
            this.AddGuard( Guard.NotNull( this.CreateDoc( ), this.Name, this.Parent.IsInternal ), configure );
            return this;
        }

        /// <summary>
        /// Ensures the assigned <see cref="Enum"/> property value is defined.
        /// </summary>
        public Property<T> EnumIsDefined( Action<Guard> configure = null ) {
            Ensure.Satisfies( typeof( T ).IsEnum, "Property type {0} is not an enum type.", typeof( T ) );
            this.AddGuard( Guard.EnumIsDefined( this.CreateDoc( ), this.Name, this.Parent.IsInternal ), configure );
            return this;
        }

        /// <summary>
        /// Creates a guard to ensure an <see cref="double"/> value is not a special value.
        /// </summary>
        public Property<T> NotSpecialValue( Action<Guard> configure = null ) {
            this.AddGuard( Guard.NotSpecialValue( this.CreateDoc( ), this.Name, this.Parent.IsInternal ), configure );
            return this;
        }

        /// <summary>
        /// Ensures the assigned property value is within the range defined by the specified condition.
        /// </summary>
        public Property<T> IsInRange( string description, Action<Guard> configure, string condition, string format, params string[] args ) {
            this.AddGuard( Guard.IsInRange( this.CreateDoc( ), this.Name, description, condition, format, args ), configure );
            return this;
        }
        public Property<T> IsInRange( string description, string condition, string format, params string[] args ) { return this.IsInRange( description, null, condition, format, args ); }
        public Property<T> IsInRange( Action<Guard> configure, string condition, string format, params string[] args ) { return this.IsInRange( null, configure, condition, format, args ); }
        public Property<T> IsInRange( string condition, string format, params string[] args ) { return this.IsInRange( null, null, condition, format, args ); }

        /// <summary>
        /// Ensures the assigned property value satisfies the requirements defined by the specified condition.
        /// </summary>
        public Property<T> Satisfies( string description, Action<Guard> configure, string condition, string format, params string[] args ) {
            this.AddGuard( Guard.Satisfies( this.CreateDoc( ), this.Name, description, condition, format, args ), configure );
            return this;
        }
        public Property<T> Satisfies( string description, string condition, string format, params string[] args ) { return this.Satisfies( description, null, condition, format, args ); }
        public Property<T> Satisfies( Action<Guard> configure, string condition, string format, params string[] args ) { return this.Satisfies( null, configure, condition, format, args ); }
        public Property<T> Satisfies( string condition, string format, params string[] args ) { return this.Satisfies( null, null, condition, format, args ); }

        #endregion

    }

#>
<#+ // TemplatePart`T.cs

    /// <inheritdoc/>
    /// <summary>
    /// Implements an named template part.
    /// </summary>
    public sealed class TemplatePart<T> : ValueAccessor<T> where T : class {

        internal const string DescriptionFormat = "Gets {0}.";


        /// <summary>
        /// Gets the part name of the template part.
        /// </summary>
        public string PartName { get { return "PART_" + this.AccessorName; } }

        /// <summary>
        /// Gets the name of the initialization helper method.
        /// </summary>
        private string HelperName { get { return "Initialize" + this.AccessorName; } }


        /// <inheritdoc/>
        protected override IEnumerable<InitializationMember> Initializers {
            get {
                var oldValueInitializer = CreateInitializer( false, "{0} old{1} = this.{1}", this.TypeName, this.AccessorName );
                var partInitializer = CreateInitializer( true, "this.GetTemplateChild(\"{0}\") as {1}", this.PartName, this.TypeName );
                var helperCall = CreateInitializer( false, "this.{0}(old{1}, this.{1})", this.HelperName, this.AccessorName );

                oldValueInitializer.DependentInitializer = partInitializer;
                partInitializer.DependentInitializer = helperCall;

                yield return oldValueInitializer;
            }
        }

        /// <inheritdoc/>
        protected override AccessorMember Accessor {
            get {
                var oldValue = new ParameterMember( "old" + this.AccessorName, this.TypeName );
                var newValue = new ParameterMember( "new" + this.AccessorName, this.TypeName );
                var helper = new MethodMember( this.HelperName, "void", null ) {
                    Parameters = { oldValue, newValue },
                    Attributes = { AttributeMember.SuppressUnusedPartialParameters }
                };

                if( GlobalSettings.CodeAnalysisRuleNamespace != null && GlobalSettings.WeakEventCodeAnalysisRule != null )
                    helper.Attributes.Add( AttributeMember.SuppressMessage(
                        GlobalSettings.CodeAnalysisRuleNamespace,
                        GlobalSettings.WeakEventCodeAnalysisRule,
                        "Template parts are guaranteed to be local to the control." ) );

                return new AccessorMember( this.AccessorName, this.TypeName ) {
                    Doc = this.CreateDoc( )
                        .AddSummary( DescriptionFormat, this.Description ),
                    Modifiers = this.AccessorModifiers,
                    ObserveMember = this.CreateAccessorBlock(
                        ObserveAccessorName,
                        string.Format( "return this.{0};", this.FieldName )
                    ),
                    Helpers = { helper }
                };
            }
        }

        private AttributeMember PartAttribute {
            get {
                var typeRepository = this.Parent.TypeRepository;
                string templatePartAttributeTypeName = typeRepository.GetTypeName( typeof( TemplatePartAttribute ) );
                string nameValue = typeRepository.GetValueString( this.PartName, false );
                string typeValue = typeRepository.GetValueString( this.Type, false );

                var partAttribute = AttributeMember.Custom( templatePartAttributeTypeName );
                partAttribute.NamedArguments.Add( "Name", nameValue );
                partAttribute.NamedArguments.Add( "Type", typeValue );

                return partAttribute;
            }
        }


        /// <inheritdoc/>
        public TemplatePart( PartialType parent, string name, string description )
            : base( parent, name, description ) {
            this.Accessibility = Accessibility.Private;
        }


        /// <inheritdoc/>
        protected override IEnumerable<Member> GetMembers( ) {
            var partAttribute = this.PartAttribute;
            Ensure.NotNull( partAttribute );

            return base.GetMembers( )
                .Concat( new[] { partAttribute } );
        }


        private InitializationMember CreateInitializer( bool writeAssignment, string format, params object[] args ) {
            return new InitializationMember( this.FieldName, string.Format( format, args ) ) {
                MemberScope = InitializationMember.OnApplyTemplateMemberScope,
                WriteVariableAssignment = writeAssignment
            };
        }

    }

#>
<#+ // ValueAccessor`T.cs

    /// <summary>
    /// Implements an accessor with a value.
    /// </summary>
    /// <typeparam name="T">The type of the property.</typeparam>
    public abstract class ValueAccessor<T> : AccessorImplementer<T>, EquatableInterface.ITarget {

        public const string PropertyFieldNamePrefix = "_privateBackingFieldForProperty_";

        protected const string MemberKind = "Property";

        /// <summary>The name of the observe accessor for a property.</summary>
        protected const string ObserveAccessorName = "get";

        /// <summary>The name of the update accessor for a property.</summary>
        protected const string UpdateAccessorName = "set";

        protected readonly string CoerceAction;
        protected readonly string ValidateAction;
        protected readonly string ChangingAction;
        protected readonly string ChangedAction;

        private readonly Dictionary<CompilationSymbol, string> defaultValues_ = new Dictionary<CompilationSymbol, string>( );


        /// <summary>
        /// Gets or sets a value indicating whether the property should be used when determining equality of the parent type.
        /// </summary>
        /// <remarks>
        /// This property is set by <see cref="PartialType.ImplementIEquatable"/>.
        /// </remarks>
        public bool Equatable { get; set; }

        /// <summary>
        /// Gets the set of default values for the property.
        /// </summary>
        public Dictionary<CompilationSymbol, string> DefaultValues { get { return this.defaultValues_; } }

        /// <inheritdoc/>
        protected override string FieldNamePrefix { get { return PropertyFieldNamePrefix; } }


        /// <inheritdoc/>
        protected ValueAccessor( PartialType parent, string name, string description )
            : base( parent, name, description ) {
            this.CoerceAction = this.GetActionName( "Coerce" );
            this.ValidateAction = this.GetActionName( "Validate" );
            this.ChangingAction = this.GetActionName( "Changing" );
            this.ChangedAction = this.GetActionName( "Changed" );
        }


        /// <summary>
        /// Adds the expression to the <see cref="DefaultValues"/> property.
        /// </summary>
        public ValueAccessor<T> AddDefaultExpression( CompilationSymbol condition, string defaultValue ) {
            this.DefaultValues.Add( condition, defaultValue );
            return this;
        }

        /// <summary>
        /// Adds the value to the <see cref="DefaultValues"/> property.
        /// </summary>
        public ValueAccessor<T> AddDefaultValue( CompilationSymbol condition, T defaultValue ) {
            bool silverlight = condition.Equals( CompilationSymbol.Silverlight );
            string stringValue = this.Parent.TypeRepository.GetValueString( defaultValue, silverlight );
            this.AddDefaultExpression( condition, stringValue );
            return this;
        }

        /// <summary>
        /// Assigns the expression used for the <see cref="DefaultValues"/> property.
        /// </summary>
        [Category( "Default Value" )]
        public ValueAccessor<T> SetDefaultExpression( string defaultValue ) {
            this.DefaultValues.Clear( );

            return this.AddDefaultExpression( CompilationSymbol.None, defaultValue );
        }

        /// <summary>
        /// Assigns the value used for the <see cref="DefaultValues"/> property.
        /// </summary>
        [Category( "Default Value" )]
        public ValueAccessor<T> SetDefaultValue( T defaultValue ) {
            string stringValue = this.Parent.TypeRepository.GetValueString( defaultValue, false );
            string silverlightValue = this.Parent.TypeRepository.GetValueString( defaultValue, true );

            if( stringValue == silverlightValue ) {
                this.SetDefaultExpression( stringValue );
            }
            else {
                this.DefaultValues.Clear( );
                this.AddDefaultExpression( CompilationSymbol.NotSilverlight, stringValue );
                this.AddDefaultExpression( CompilationSymbol.Silverlight, silverlightValue );
            }

            return this;
        }


        #region ITarget Members

        /// <inheritdoc/>
        string EquatableInterface.ITarget.PropertyName {
            get { return this.AccessorName; }
        }

        /// <inheritdoc/>
        void EquatableInterface.ITarget.Prepare( EquatableInterface implementer ) { }

        #endregion

    }

#>
<#+ // AccessorMember.cs

    /// <summary>
    /// Writes code for an accessor (i.e. property, event).
    /// </summary>
    public sealed class AccessorMember : HelpedMember {

        private BlockMember observeMember_;
        private BlockMember updateMember_;


        /// <inheritdoc/>
        public override Extensions UsedExtensions {
            get {
                return base.UsedExtensions
                     | Util.GetUsedExtensions( this.ObserveMember, this.UpdateMember );
            }
        }

        /// <summary>
        /// Gets or sets the member used to observe the accessor.
        /// </summary>
        public BlockMember ObserveMember {
            get { return this.observeMember_; }
            set {
                this.observeMember_ = value;
                this.UpdateDoc( value );
            }
        }

        /// <summary>
        /// Gets or sets the member used to update the accessor.
        /// </summary>
        public BlockMember UpdateMember {
            get { return this.updateMember_; }
            set {
                this.updateMember_ = value;
                this.UpdateDoc( value );
            }
        }


        /// <summary>
        /// Initializes a new <see cref="AccessorMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the accessor.</param>
        /// <param name="type">The type of the accessor.</param>
        public AccessorMember( string name, string type )
            : base( name, type, "public" ) { }


        /// <inheritdoc/>
        protected override void WriteCore( ICodeWriter writer ) {
            writer.WriteLine( "{0} {1} {2}", this.Modifiers, this.Type, this.Name );

            var observe = this.ObserveMember ?? Member.Empty;
            var update = this.UpdateMember ?? Member.Empty;

            using( Enclose.Braces( writer ) ) {
                observe.Write( writer );
                update.Write( writer );
            }
        }


        private void UpdateDoc( BlockMember block ) {
            if( block != null && this.Doc != null )
                this.Doc.AddExceptions( block.Guards );
        }

    }

#>
<#+ // AttributeMember.cs

    /// <summary>
    /// Writes code for a constant declaration.
    /// </summary>
    public sealed class AttributeMember : Member {

        public static readonly AttributeMember EmptyAttribute = new AttributeMember( );

        /// <summary>Declares the <see cref="EditorBrowsableAttribute"/> with the <see cref="EditorBrowsableState.Never"/> state.</summary>
        public static readonly AttributeMember EditorBrowsableNever;

        /// <summary>Declares the <see cref="SuppressMessageAttribute"/> for unused parameters on partial helper methods.</summary>
        public static readonly AttributeMember SuppressUnusedPartialParameters;

        /// <summary>Declares the <see cref="SuppressMessageAttribute"/> for static members in generic types.</summary>
        public static readonly AttributeMember SuppressStaticMembersInGenericTypes;

        private const string AttributeSuffix = "Attribute";
        private static readonly string SuppressMessageTypeName;

        private readonly bool isEmpty_;
        private readonly string[] positionalArguments_;
        private readonly Dictionary<string, string> namedArguments_ = new Dictionary<string, string>( );


        /// <inheritdoc/>
        public override Extensions UsedExtensions { get { return Extensions.None; } }

        /// <summary>
        /// Gets the positional arguments of the attribute.
        /// </summary>
        public IEnumerable<string> PositionalArguments { get { return this.positionalArguments_.AsEnumerable( ); } }

        /// <summary>
        /// Gets the named arguments of the attribute.
        /// </summary>
        public IDictionary<string, string> NamedArguments { get { return this.namedArguments_; } }


        static AttributeMember( ) {
            SuppressMessageTypeName = typeof( SuppressMessageAttribute ).FullName;

            EditorBrowsableNever = new AttributeMember(
                typeof( EditorBrowsableAttribute ).FullName,
                typeof( EditorBrowsableState ).FullName + "." + EditorBrowsableState.Never
            );

            SuppressUnusedPartialParameters = AttributeMember.SuppressMessage( "Microsoft.Usage", "CA1801:ReviewUnusedParameters", "Partial method definitions are not required to use method parameters." );
            SuppressStaticMembersInGenericTypes = AttributeMember.SuppressMessage( "Microsoft.Design", "CA1000:DoNotDeclareStaticMembersOnGenericTypes", "Part of standard property implementation." );
        }

        /// <summary>
        /// Initializes a new <see cref="AttributeMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the attribute type.</param>
        /// <param name="positionalArguments">The positional arguments of the attribute.</param>
        private AttributeMember( string name, params string[] positionalArguments )
            : base( name ) {
            Ensure.NotNull( (object)positionalArguments );

            this.positionalArguments_ = positionalArguments;
            this.isEmpty_ = false;
        }

        /// <summary>
        /// Initializes a new empty <see cref="AttributeMember"/> instance.
        /// </summary>
        private AttributeMember( )
            : base( Member.Empty.Name ) {
            this.positionalArguments_ = new string[0];
            this.isEmpty_ = true;
        }


        public static AttributeMember Custom(string typeName, params string[] positionalArguments)
        {
            if( typeName.EndsWith( AttributeSuffix ) )
                typeName = typeName.Substring( 0, typeName.Length - AttributeSuffix.Length );

            return new AttributeMember(typeName, positionalArguments);
        }

        public static AttributeMember SuppressMessage( string category, string id, string justification ) {
            id = TypeRepository.EscapeString( id );
            category = TypeRepository.EscapeString( category );
            justification = TypeRepository.EscapeString( justification );

            return new AttributeMember( SuppressMessageTypeName, category, id ) {
                NamedArguments = { { "Justification", justification } }
            };
        }

        public static AttributeMember SuppressMessage( string category, string id, string messageId, string justification ) {
            messageId = TypeRepository.EscapeString( messageId );

            var attribute = SuppressMessage( category, id, justification );
            attribute.NamedArguments.Add( "MessageId", messageId );

            return attribute;
        }


        /// <inheritdoc/>
        protected override void WriteCore( ICodeWriter writer ) {
            if( this.isEmpty_ )
                return;

            using( Enclose.Brackets( writer ) ) {
                writer.Write( this.Name );
                using( Enclose.Parenthesis( writer ) ) {
                    Util.Iterate(
                        this.PositionalArguments,
                        ( i, last ) => writer.Write( ", " ),
                        ( i, arg ) => writer.Write( arg )
                    );

                    if( this.PositionalArguments.Any( ) && this.NamedArguments.Any( ) )
                        writer.Write( ", " );
                    Util.Iterate(
                        this.NamedArguments,
                        ( i, last ) => writer.Write( ", " ),
                        ( i, arg ) => writer.Write( arg.Key + " = " + arg.Value )
                    );
                }
            }
            writer.WriteLine( );
        }

    }

#>
<#+ // BlockMember.cs

    /// <summary>
    /// Writes a named block of code enclosed.
    /// </summary>
    public sealed class BlockMember : Member {

        private readonly string contentValue_;
        private readonly Action<ICodeWriter> content_;
        private readonly List<Guard> guards_ = new List<Guard>( );


        /// <inheritdoc/>
        public override Extensions UsedExtensions {
            get { return this.Guards.Any( ) ? Extensions.Validation : Extensions.None; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the block should write it's name before the body.
        /// </summary>
        public bool WriteName { get; set; }

        /// <summary>
        /// Gets or sets a writer for content preceding any block guards.
        /// </summary>
        public Action<ICodeWriter> PreContent { get; set; }

        /// <summary>
        /// Gets the content string for the body of the block.
        /// </summary>
        public string ContentValue { get { return this.contentValue_; } }

        /// <summary>
        /// Gets the content writer for the body of the block.
        /// </summary>
        public Action<ICodeWriter> Content { get { return this.content_; } }

        /// <summary>
        /// Gets the collections of guards for the member.
        /// </summary>
        public IEnumerable<Guard> Guards { get { return this.guards_.AsEnumerable( ); } }


        /// <summary>
        /// Initializes a new <see cref="BlockMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the block.</param>
        /// <param name="content">The content for the body of the block.</param>
        public BlockMember( string name, string content )
            : base( name ) {
            this.contentValue_ = content ?? "";
            this.content_ = null;
        }

        /// <summary>
        /// Initializes a new <see cref="BlockMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the block.</param>
        /// <param name="content">The content writer for the body of the block.</param>
        public BlockMember( string name, Action<ICodeWriter> content )
            : base( name ) {
            Ensure.NotNull( content );

            this.contentValue_ = "";
            this.content_ = content;
        }


        /// <summary>
        /// Adds guards to the member.
        /// </summary>
        public BlockMember AddGuards( IEnumerable<Guard> newGuards ) {
            this.guards_.AddRange( newGuards );
            return this;
        }


        /// <inheritdoc/>
        protected override void WriteCore( ICodeWriter writer ) {
            if( this.PreContent == null && this.Content == null && !this.Guards.Any( ) ) {
                if( this.WriteName )
                    writer.Write( this.Name + " " );
                writer.Write( "{ " );
                if( this.ContentValue.Length > 0 )
                    writer.Write( this.ContentValue + " " );
                writer.WriteLine( "}" );
            }
            else {
                if( this.WriteName )
                    writer.WriteLine( this.Name );

                using( Enclose.Braces( writer ) ) {
                    if( this.PreContent != null ) {
                        this.PreContent( writer );
                        writer.WriteLine( );
                    }

                    Guard.WriteGuards( writer, this.Guards );

                    if( this.ContentValue.Length > 0 )
                        writer.WriteLine( this.ContentValue );

                    if( this.Content != null )
                        this.Content( writer );
                }
            }
        }

    }

#>
<#+ // ConstantMember.cs

    /// <summary>
    /// Writes code for a constant declaration.
    /// </summary>
    public sealed class ConstantMember : ModifiedTypedMember {

        private readonly string value_;


        /// <inheritdoc/>
        public override Extensions UsedExtensions { get { return Extensions.None; } }

        /// <summary>
        /// Gets the value of the constant.
        /// </summary>
        public string Value { get { return this.value_; } }


        /// <summary>
        /// Initializes a new <see cref="ConstantMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the constant.</param>
        /// <param name="type">The type of the constant.</param>
        /// <param name="value">The value of the constant.</param>
        public ConstantMember( string name, string type, string value )
            : base( name, type, "public const" ) {
            Ensure.NotNullOrEmpty( value );

            this.value_ = value;

            this.SpaceOutput = true;
        }


        /// <inheritdoc/>
        protected override void WriteCore( ICodeWriter writer ) {
            writer.WriteLine( "{0} {1} {2} = {3};", this.Modifiers, this.Type, this.Name, this.Value );
        }

    }

#>
<#+ // Doc.cs

    /// <summary>
    /// Contains documentation for a <see cref="Member"/>.
    /// </summary>
    public sealed class Doc : IWritable {

        /// <summary>Delimit expandable replacements.</summary>
        public const char ExpanderDelimiter = '%';

        /// <summary>Delimit arguments for expandable replacements.</summary>
        public const char ExpanderArgumentsDelimiter = ':';

        /// <summary>Replaced with the name of the member.</summary>
        public const string Name = "name";

        /// <summary>Replaced with the type of the member.</summary>
        public const string Type = "type";

        /// <summary>Replaced with the name of the parent type.</summary>
        public const string ParentType = "parent_type";


        private static readonly Dictionary<string, string> StandardReplacements = new Dictionary<string, string> {
            { " null", " <see langword='null'/>" },
            { " true", " <see langword='true'/>" },
            { " false", " <see langword='false'/>" },
            { "null ", "<see langword='null'/> " },
            { "true ", "<see langword='true'/> " },
            { "false ", "<see langword='false'/> " },
        };
        private static readonly Dictionary<string, string> StandardExpanders = new Dictionary<string, string> {
            { "see", "<see cref='{0}'/>" },
            { "seealso", "<seealso cref='{0}'/>" },
            { "langword", "<see langword='{0}'/>" },
            { "paramref", "<paramref name='{0}'/>" },
            { "typeparamref", "<typeparamref name='{0}'/>" },
            { "inherit", "<inheritdoc/>" },
            { "inheritfrom", "<inheritdoc cref='{0}'/>" },
        };


        private readonly Dictionary<string, string> replacements_;
        private readonly Dictionary<string, string> expanders_;
        private readonly List<DocElement> docElements_ = new List<DocElement>( );
        private readonly string fullyQualifiedName_;
        private readonly string includeType_;
        private Options options_;


        /// <summary>
        /// Gets or sets the member to inherit from.
        /// </summary>
        /// <remarks>
        /// If set to <null/>, the <c>inherit</c> element will not be added.
        /// If set to an empty <see cref="string"/>, the <c>inherit</c> element will be added without the <c>from</c> attribute.
        /// Otherwise, the <c>inherit</c> element will be added with the <c>from</c> attribute set to the specified value.
        /// </remarks>
        public string InheritFrom { get; set; }

        /// <summary>
        /// Gets the fully-qualified name of the member being documented.
        /// </summary>
        public string FullyQualifiedName { get { return this.fullyQualifiedName_; } }


        public Doc( string fullyQualifiedName, string name, string type, string parentType )
            : this( fullyQualifiedName, parentType ?? name, StandardReplacements, StandardExpanders ) {
            Ensure.NotNullOrEmpty( name );
            Ensure.NotNullOrEmpty( type );

            this.expanders_[Doc.Name] = name;
            this.expanders_[Doc.Type] = GetDocTypeName( type );
            this.expanders_[Doc.ParentType] = GetDocTypeName( parentType ?? "" );
        }

        public Doc( Doc doc ) : this( doc.fullyQualifiedName_, doc.includeType_, doc.replacements_, doc.expanders_ ) { }

        private Doc( string fullyQualifiedName, string includeType, IDictionary<string, string> initialReplacements, IDictionary<string, string> initialExpanders ) {
            Ensure.NotNullOrEmpty( fullyQualifiedName );

            this.fullyQualifiedName_ = fullyQualifiedName;
            this.replacements_ = new Dictionary<string, string>( initialReplacements );
            this.expanders_ = new Dictionary<string, string>( initialExpanders );
            this.includeType_ = includeType.Replace( '<', '`' ).Replace( ", ", "," ).Replace( ">", "" );
        }


        /// <summary>
        /// Updates the documentation settings to use an include tag.
        /// </summary>
        public Doc UseIncludeTag( ) {
            this.options_ |= Options.UseIncludeTag;
            return this;
        }

        /// <summary>
        /// Updates the documentation settings to use the documentation members.
        /// </summary>
        public Doc UseDocMembers( bool onlyDocMembers = false ) {
            if( onlyDocMembers )
                this.options_ = Options.UseDocMembers;
            else
                this.options_ |= Options.UseDocMembers;
            return this;
        }

        /// <summary>
        /// Updates the documentation settings based on the state of the child documentation elements.
        /// </summary>
        public void UpdateSettings( IEnumerable<Doc> children ) {
            if( children == null )
                return;

            foreach( Doc child in children )
                if( child != null )
                    this.options_ |= child.options_;

            if( this.options_ == Options.UseIncludeTag )
                foreach( Doc child in children )
                    if( child != null )
                        child.options_ = Options.NoDocMembers;
        }


        /// <summary>
        /// Gets the name of a type that can be used in <c>see</c> documentation elements.
        /// </summary>
        public static string GetDocTypeName( string typeName, bool? showNumberedGenericArguments = true ) {
            Ensure.NotNull( typeName );

            // Replace angle brackets on generic types with braces and type arguments with general names.
            int genericStart = typeName.IndexOf( '<' );
            if( genericStart > 0 && showNumberedGenericArguments.HasValue ) {
                string name = typeName.Substring( 0, genericStart );
                int argumentsLength = typeName.Length - genericStart - 2;
                string arguments = typeName.Substring( genericStart + 1, argumentsLength );

                int parameterCount = 1;
                int nestedParameter = 0;
                foreach( char c in arguments ) {
                    switch( c ) {
                        case ',':
                            if( nestedParameter == 0 )
                                ++parameterCount;
                            break;
                        case '<':
                            ++nestedParameter;
                            break;
                        case '>':
                            --nestedParameter;
                            break;
                        default:
                            break;
                    }
                }

                if( showNumberedGenericArguments == true ) {
                    string genericArguments = parameterCount == 1 ? "T" : string.Join( ",", Enumerable.Range( 0, parameterCount ).Select( i => "T" + i ) );
                    typeName = name + "{" + genericArguments + "}";
                }
                else {
                    typeName = name + "`" + parameterCount;
                }
            }
            else if( genericStart > 0 ) {
                typeName = typeName.Replace( '<', '{' ).Replace( '>', '}' ).Replace( " ", "" );
            }

            return typeName;
        }


        /// <summary>
        /// Adds a replacement replacement value.
        /// </summary>
        public Doc AddReplacement( string key, string format, params object[] args ) {
            Ensure.NotNullOrEmpty( key );
            Ensure.NotNull( format );

            string value = string.Format( format, args );
            this.replacements_[key] = value;
            return this;
        }

        /// <summary>
        /// Adds the specified replacement replacement values.
        /// </summary>
        public Doc AddReplacements( ReplacementsDictionary replacements ) {
            Ensure.NotNull( replacements );

            foreach( var replacement in replacements )
                this.AddReplacement( replacement.Key, replacement.Value );
            return this;
        }

        /// <summary>
        /// Adds an expandable replacement value.
        /// </summary>
        public Doc AddExpander( string key, string format ) {
            Ensure.NotNullOrEmpty( key );
            Ensure.NotNull( format );

            this.expanders_[key] = format;
            return this;
        }

        /// <summary>
        /// Applies replacements to the specified string.
        /// </summary>
        public string ApplyReplacements( string value ) {
            Ensure.NotNull( value );

            var sb = new StringBuilder( );

            // Replace any replacement values resulting in expanders.
            foreach( var replacement in this.replacements_ )
                if( replacement.Value.Contains( ExpanderDelimiter ) )
                    value = value.Replace( replacement.Key, replacement.Value );

            // Expand each delimited value.
            int lastDelimiter = 0;
            int startDelimiter = value.IndexOf( ExpanderDelimiter, lastDelimiter );
            while( startDelimiter >= 0 ) {
                // Append intermediate text between delimiters.
                sb.Append( value.Substring( lastDelimiter, startDelimiter - lastDelimiter ) );

                // Expand text between delimiters.
                int endDelimiter = value.IndexOf( ExpanderDelimiter, startDelimiter + 1 );
                Ensure.Satisfies( endDelimiter > 0, "Could not find end delimiter for start delimiter at {0} in string '{1}'.", startDelimiter, value );
                string delimitedText = value.Substring( startDelimiter + 1, endDelimiter - startDelimiter - 1 );
                string[] parts = delimitedText.Split( new[] { ExpanderArgumentsDelimiter }, StringSplitOptions.RemoveEmptyEntries );
                if( parts.Length == 0 ) {
                    sb.Append( ExpanderDelimiter );
                }
                else {
                    string expanderKey = parts[0];
                    string format = this.expanders_[expanderKey];

                    // Expand any arguments.
                    string[] arguments = parts.Skip( 1 ).ToArray( );
                    for( int i = 0; i < arguments.Length; ++i ) {
                        string[] argParts = arguments[i].Split( new[] { '.' }, 2 );
                        string argRoot = argParts[0];
                        if( this.expanders_.ContainsKey( argRoot ) )
                            argParts[0] = this.expanders_[argRoot];
                        arguments[i] = string.Join( ".", argParts );
                    }

                    sb.AppendFormat( format, arguments );
                }

                // Check for next delimiter.
                lastDelimiter = endDelimiter + 1;
                startDelimiter = value.IndexOf( ExpanderDelimiter, lastDelimiter + 1 );
            }

            // Append any text after last delimiter.
            sb.Append( value.Substring( lastDelimiter ) );

            // Replace primitive values.
            foreach( var replacement in this.replacements_ )
                sb.Replace( replacement.Key, replacement.Value );

            return sb.ToString( );
        }


        /// <summary>
        /// Adds a named documentation element with the specified content.
        /// </summary>
        /// <remarks>
        /// Adding multiple elements with the same name will output a single doc element with multiple <c>para</c> sections.
        /// </remarks>
        public Doc AddDocElement( string name, string format, params object[] args ) {
            if( format == null ) {
                this.options_ |= Options.UseIncludeTag;
                return this;
            }

            Ensure.NotNullOrEmpty( name );
            Ensure.NotNullOrEmpty( format );

            string value = args.Length > 0 ? string.Format( format, args ) : format;
            this.docElements_.Add( new DocElement( this, name, value ) );

            return this;
        }

        /// <summary>
        /// Adds documentation elements created from existing xml documentation.
        /// </summary>
        public Doc AddDocElements( IEnumerable<XElement> elements ) {
            Ensure.NotNull( elements );

            var validElements = XmlDocumentation.FilterElements( elements, "filterpriority" );
            foreach( var element in validElements ) {
                string elementName = XmlDocumentation.GetElementName( element );
                string elementValue = XmlDocumentation.GetElementValue( element );

                this.AddDocElement( elementName, elementValue );
            }

            return this;
        }

        /// <summary>
        /// Adds a <c>summary</c> documentation element with the specified content.
        /// </summary>
        public Doc AddSummary( string format, params object[] args ) {
            if( args.Length == 1 && args[0] == null ) {
                this.options_ |= Options.UseIncludeTag;
                return this;
            }

            string actionParameter = args.FirstOrDefault( ) as string ?? "";

            if( actionParameter.StartsWith( "%lookup:" ) ) {
                string lookup = actionParameter.Split( new[] { ExpanderArgumentsDelimiter }, 2 )[1];

                int memberNameIndex = lookup.LastIndexOf( '.' );
                string lookupTypeName = lookup.Substring( 0, memberNameIndex );
                string lookupMemberName = lookup.Substring( memberNameIndex + 1 );

                Type lookupType = AppDomain.CurrentDomain.GetAssemblies( )
                    .Select( a => a.GetType( lookupTypeName, false, true ) )
                    .FirstOrDefault( t => t != null );
                if( lookupType == null ) { throw new InvalidOperationException( "Could not find type for member " + lookup ); }

                var lookupMember = lookupType.GetMember( lookupMemberName ).First( );

                var lookupDoc = XmlDocumentation.GetDocMember( lookupMember );
                this.AddDocElements( lookupDoc.Elements( ) );
            }
            else if( actionParameter == "%inherit%" )
                this.InheritFrom = "";
            else
                this.AddDocElement( "summary", format, args );

            return this;
        }

        /// <summary>
        /// Adds a <c>returns</c> documentation element with the specified content.
        /// </summary>
        public Doc AddReturns( string format, params object[] args ) {
            return this.AddDocElement( "returns", format, args );
        }

        /// <summary>
        /// Adds a <c>param</c> documentation element with the specified content.
        /// </summary>
        public Doc AddParam( string paramName, string format, params object[] args ) {
            Ensure.NotNullOrEmpty( paramName );

            string name = string.Format( "param name='{0}'", paramName );
            return this.AddDocElement( name, format, args );
        }

        /// <summary>
        /// Adds an <c>exception</c> documentation element with the specified content.
        /// </summary>
        public Doc AddException( string exceptionTypeName, string format, params object[] args ) {
            Ensure.NotNullOrEmpty( exceptionTypeName );

            string name = string.Format( "exception cref='{0}'", exceptionTypeName );
            return this.AddDocElement( name, format, args );
        }

        /// <summary>
        /// Adds <c>exception</c> documentation elements for each of the specified <see cref="Guard"/>s.
        /// </summary>
        public Doc AddExceptions( IEnumerable<Guard> guards ) {
            Ensure.NotNull( guards );

            foreach( var guard in guards )
                if( !guard.IsEmpty )
                    this.AddException( guard.ExceptionType.FullName, guard.Description );

            return this;
        }


        /// <inheritdoc/>
        public void Write( ICodeWriter writer ) {
            using( writer.PushIndent( "/// " ) ) {
                if( this.options_ == Options.None || this.options_.HasFlag( Options.UseDocMembers ) ) {
                    // Write an "inherit" element, if it is set.
                    if( this.InheritFrom != null ) {
                        string inheritFrom = this.ApplyReplacements( this.InheritFrom );
                        string crefAttribute = inheritFrom.Length > 0 ? " cref='" + inheritFrom + "'" : "";

                        writer.WriteLine( "<inheritdoc{0}/>", crefAttribute );
                    }

                    // Write each doc element, writing out values with the same name under one element separated by "para" tags.
                    var groupedElements = this.docElements_.GroupBy( e => e.Name, e => e.Value );
                    foreach( var group in groupedElements ) {
                        string attributedElementName = group.Key;
                        string elementName = attributedElementName.Split( ' ' ).First( );

                        Action<int, bool> separate = delegate { };
                        if( elementName == "exception" ) {
                            // Separate each exception cause by "-or-".
                            const string SeparatorValue = "<para>-or-</para>";
                            separate = ( i, last ) => writer.WriteLine( SeparatorValue );
                        }

                        Action<int, string> operate = ( i, value ) => {
                            if( i == 0 )
                                writer.WriteLine( value );
                            else
                                using( Enclose.Format( writer, "<para>", "</para>" ) )
                                using( writer.PushIndent( "  " ) )
                                    writer.WriteLine( value );
                        };

                        using( Enclose.Format( writer, "<{0}>", "</{1}>", attributedElementName, elementName ) )
                            Util.Iterate( group, separate, operate );
                    }
                }

                // Write include tag, if needed.
                if( this.options_.HasFlag( Options.UseIncludeTag ) ) {
                    writer.WriteLine(
                        "<include file='{0}{1}.xml' path='/doc/member[@name=\"{2}\"]/*' />",
                        GlobalSettings.ExternalDocumentationPrefix, this.includeType_, this.fullyQualifiedName_
                    );
                }
            }
        }


        [Flags]
        private enum Options {
            None = 0,
            UseDocMembers = 1 << 0,
            UseIncludeTag = 1 << 1,
            NoDocMembers = 1 << 2,
        }

        public sealed class ReplacementsDictionary : IEnumerable<KeyValuePair<string, string>> {
            private readonly Dictionary<string, string> replacements_ = new Dictionary<string, string>( );

            public ReplacementsDictionary Add( string key, string format, params object[] args ) {
                string value = string.Format( format, args );
                this.replacements_.Add( key, value );
                return this;
            }

            public IEnumerator<KeyValuePair<string, string>> GetEnumerator( ) { return this.replacements_.GetEnumerator( ); }
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator( ) { return this.GetEnumerator( ); }
        }

        private sealed class DocElement {
            private readonly Doc parent_;
            private readonly string name_;
            private readonly string rawValue_;

            public string Name { get { return this.name_; } }
            public string Value { get { return this.parent_.ApplyReplacements( this.rawValue_ ); } }

            public DocElement( Doc parent, string name, string rawValue ) {
                Ensure.NotNull( parent );
                Ensure.NotNullOrEmpty( name );
                Ensure.NotNullOrEmpty( rawValue );

                this.parent_ = parent;
                this.name_ = name;
                this.rawValue_ = rawValue;
            }
        }

    }

#>
<#+ // FieldMember.cs

    /// <summary>
    /// Writes code for a field declaration.
    /// </summary>
    public sealed class FieldMember : ModifiedTypedMember {

        /// <inheritdoc/>
        public override Extensions UsedExtensions { get { return Extensions.None; } }


        /// <summary>
        /// Initializes a new <see cref="FieldMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the field.</param>
        /// <param name="type">The type of the field.</param>
        public FieldMember( string name, string type )
            : base( name, type, "private" ) {
        }


        /// <inheritdoc/>
        protected override void WriteCore( ICodeWriter writer ) {
            writer.WriteLine( "{0} {1} {2};", this.Modifiers, this.Type, this.Name );
        }

    }

#>
<#+ // Guard.cs

    /// <summary>
    /// Writes a named block of code enclosed.
    /// </summary>
    public sealed class Guard : IWritable {

        /// <summary>
        /// An empty guard that can be used as a flag for including the validation sub-namespace.
        /// </summary>
        public static Guard Empty = new Guard( );

        private readonly bool isEmpty_;
        private readonly Doc doc_;
        private readonly string guardName_;
        private readonly string valueName_;
        private readonly Type exceptionType_;
        private readonly string description_;
        private readonly List<string> arguments_ = new List<string>( );


        /// <summary>
        /// Gets a value indicating whether this is the <see cref="Empty"/> guard.
        /// </summary>
        public bool IsEmpty { get { return this.isEmpty_; } }

        /// <summary>
        /// Gets or sets a value indicating whether this is a "Value" or "Param" guard.
        /// </summary>
        public bool IsValueGuard { get; set; }

        /// <summary>
        /// Gets or sets the priority of the guard.
        /// </summary>
        public int Priority { get; set; }

        /// <summary>
        /// Gets the name of the guard.
        /// </summary>
        public string GuardName { get { return this.guardName_; } }

        /// <summary>
        /// Gets the name of the value protected by the guard.
        /// </summary>
        public string ValueName { get { return this.valueName_; } }

        /// <summary>
        /// Gets the type of the exception thrown by the guard.
        /// </summary>
        public Type ExceptionType { get { return this.exceptionType_; } }

        /// <summary>
        /// Gets the documentation for the guard.
        /// </summary>
        public string Description { get { return this.description_ == null ? null : this.IsEmpty ? "" : this.doc_.ApplyReplacements( this.description_ ); } }

        /// <summary>
        /// Gets the list of arguments for the guard.
        /// </summary>
        public IList<string> Arguments { get { return this.arguments_; } }


        /// <summary>
        /// Initializes a new <see cref="Guard"/> instance.
        /// </summary>
        /// <param name="doc">The documentation for the parent member.</param>
        /// <param name="guardName">The name of the guard method.</param>
        /// <param name="valueName">The name of the parameter to guard.</param>
        /// <param name="exceptionType">The type of the exception thrown by the guard.</param>
        /// <param name="description">The summary documentation for the guard.</param>
        /// <param name="ensureDescription">A value indicating whether to verify <paramref name="description"/>.</param>
        public Guard( Doc doc, string guardName, string valueName, Type exceptionType, string description, bool ensureDescription = true ) {
            Ensure.NotNull( doc );
            Ensure.NotNullOrEmpty( guardName );
            Ensure.NotNullOrEmpty( valueName );
            Ensure.NotNull( exceptionType );
            if( ensureDescription ) {
                if( GlobalSettings.ExternalDocumentationPrefix != null && !string.IsNullOrEmpty( description ) )
                    throw new InvalidOperationException( guardName + " guard description '" + description + "' cannot be used when specifying external documentation." );
                if( GlobalSettings.ExternalDocumentationPrefix == null && string.IsNullOrEmpty( description ) )
                    throw new InvalidOperationException( guardName + " guard description must be specified when not using external documentation." );
            }

            this.isEmpty_ = false;
            this.doc_ = new Doc( doc ).AddExpander( Doc.Name, valueName );

            this.guardName_ = guardName;
            this.valueName_ = valueName;
            this.exceptionType_ = exceptionType;
            this.description_ = description;
        }

        private Guard( ) {
            this.isEmpty_ = true;
            this.doc_ = null;
            this.exceptionType_ = null;
            this.guardName_ = this.valueName_ = this.description_ = "";
        }


        /// <inheritdoc/>
        public void Write( ICodeWriter writer ) {
            string argumentsString = Util.Join( this.Arguments, ", " );
            writer.Write( ".{0}({1})", this.GuardName, argumentsString );
        }


        /// <inheritdoc/>
        public Guard SetPriority( int priority ) {
            this.Priority = priority;
            return this;
        }


        #region Standard Guards

        /// <summary>
        /// Creates a guard to ensure a value is not <null/>.
        /// </summary>
        public static Guard NotNull( Doc doc, string valueName, bool forceDescription ) {
            return new Guard( doc, "NotNull", valueName, typeof( ArgumentNullException ), forceDescription || GlobalSettings.ExternalDocumentationPrefix == null ? "%paramref:name% is null." : null, !forceDescription );
        }

        /// <summary>
        /// Creates a guard to ensure an <see cref="Enum"/> value is defined.
        /// </summary>
        public static Guard EnumIsDefined( Doc doc, string valueName, bool forceDescription ) {
            return new Guard( doc, "EnumIsDefined", valueName, typeof( ArgumentException ), forceDescription || GlobalSettings.ExternalDocumentationPrefix == null ? "%paramref:name% is not a valid %see:type% value." : null, !forceDescription );
        }

        /// <summary>
        /// Creates a guard to ensure an <see cref="double"/> value is not a special value.
        /// </summary>
        public static Guard NotSpecialValue( Doc doc, string valueName, bool forceDescription ) {
            return new Guard( doc, "NotSpecialValue", valueName, typeof( ArgumentOutOfRangeException ), forceDescription || GlobalSettings.ExternalDocumentationPrefix == null ? "%paramref:name% is %see:double.NaN%, %see:double.NegativeInfinity%, or %see:double.PositiveInfinity%." : null, !forceDescription );
        }

        /// <summary>
        /// Creates a guard to ensure a value is within the range defined by the specified condition.
        /// </summary>
        public static Guard IsInRange( Doc doc, string valueName, string description, string condition, string format, params string[] args ) {
            return Guard.AddArguments(
                new Guard( doc, "IsInRange", valueName, typeof( ArgumentOutOfRangeException ), description ),
                condition, format, args
            );
        }

        /// <summary>
        /// Creates a guard to ensure a value satisfies the requirements defined by the specified condition.
        /// </summary>
        public static Guard Satisfies( Doc doc, string valueName, string description, string condition, string format, params string[] args ) {
            return Guard.AddArguments(
                new Guard( doc, "Satisfies", valueName, typeof( ArgumentException ), description ),
                condition, format, args
            );
        }

        /// <summary>
        /// Creates a guard to ensure an accessor satisfies the requirements defined by the specified condition.
        /// </summary>
        public static Guard AccessorSatisfies( Doc doc, string valueName, string description, string condition, string format, params string[] args ) {
            return Guard.AddArguments(
                new Guard( doc, "Satisfies", valueName, typeof( InvalidOperationException ), description ) { IsValueGuard = true, Priority = 1 },
                condition, format, args
            );
        }


        private static Guard AddArguments( Guard guard, string condition, string format, IEnumerable<string> remainingArgs ) {
            Ensure.NotNull( guard, remainingArgs );
            Ensure.NotNullOrEmpty( condition );
            Ensure.NotNullOrEmpty( format );

            guard.Arguments.Add( condition );
            guard.Arguments.Add( '"' + format + '"' );
            foreach( string arg in remainingArgs )
                guard.Arguments.Add( arg );

            return guard;
        }

        #endregion

        /// <summary>
        /// Writes each guard in the specified collection from highest to lowest priority.
        /// </summary>
        public static void WriteGuards( ICodeWriter writer, IEnumerable<Guard> guards ) {
            Ensure.NotNull( writer, guards );

            var guardsByKind = guards
                .Where( g => !g.IsEmpty )
                .OrderByDescending( g => g.Priority )
                .GroupBy( g => g.IsValueGuard ? "Value" : "Param" )
                .ToArray( );

            foreach( var kind in guardsByKind ) {
                string guardKind = kind.Key;
                var targetedGuards = kind.GroupBy( g => g.ValueName );

                foreach( var group in targetedGuards ) {
                    string guardTarget = group.Key;

                    writer.WriteLine( "{0}.Guard{1}(\"{0}\")", guardTarget, guardKind );
                    using( Enclose.Indent( writer ) ) {
                        Util.Iterate( group, ( i, last ) => writer.WriteLine( ), ( i, guard ) => guard.Write( writer ) );
                        writer.WriteLine( ";" );
                    }
                }
            }

            if( guardsByKind.Any( ) )
                writer.WriteLine( );
        }

        /// <summary>
        /// Returns a new collection of guards with <see cref="Guard.ValueName"/> set to the specified value.
        /// </summary>
        public static Guard[] ChangeValueName( IEnumerable<Guard> guards, string valueName ) {
            Ensure.NotNull( guards );
            Ensure.NotNullOrEmpty( valueName );

            return guards.Select( guard =>
                new Guard( guard.doc_, guard.guardName_, valueName, guard.exceptionType_, guard.description_, false ) {
                    Priority = guard.Priority
                }.SetArguments( guard.Arguments )
            ).ToArray( );
        }


        private Guard SetArguments( IEnumerable<string> arguments ) {
            this.arguments_.AddRange( arguments );
            return this;
        }

    }

#>
<#+ // HelpedMember.cs

    /// <summary>
    /// Writes code for a member with helpers.
    /// </summary>
    public abstract class HelpedMember : ModifiedTypedMember {

        private readonly List<Member> helpers_ = new List<Member>( );


        /// <inheritdoc/>
        public override Extensions UsedExtensions {
            get { return Util.GetUsedExtensions( this.helpers_ ); }
        }

        /// <summary>
        /// Gets the collection of helpers used by the member.
        /// </summary>
        public IList<Member> Helpers { get { return this.helpers_; } }


        /// <summary>
        /// Initializes a new <see cref="HelpedMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the member.</param>
        /// <param name="type">The type of the member.</param>
        /// <param name="modifiers">The modifiers on the member.</param>
        protected HelpedMember( string name, string type, string modifiers )
            : this( name, type, true, modifiers ) { }

        /// <summary>
        /// Initializes a new <see cref="HelpedMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the member.</param>
        /// <param name="type">The type of the member.</param>
        /// <param name="isTypeRequired">Indicates whether <paramref name="type"/> must be set.</param>
        /// <param name="modifiers">The modifiers on the member.</param>
        protected HelpedMember( string name, string type, bool isTypeRequired, string modifiers )
            : base( name, type, isTypeRequired, modifiers ) {
            this.SpaceOutput = true;
        }


        /// <inheritdoc/>
        protected override void PostWrite( ICodeWriter writer ) {
            base.PostWrite( writer );
            if( this.Helpers.Any( ) ) {
                writer.WriteLine( );
                WriteMembers( writer, this.Helpers );
            }
        }

    }

#>
<#+ // InheritanceMember.cs

    /// <summary>
    /// Writes code for an inheritance declaration.
    /// </summary>
    public sealed class InheritanceMember : Member {

        private readonly Extensions extensions_;

        /// <inheritdoc/>
        public override Extensions UsedExtensions { get { return this.extensions_; } }


        /// <summary>
        /// Initializes a new <see cref="InheritanceMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the group.</param>
        /// <param name="extensions">Indicates whether the inherited type is in an extension namespace.</param>
        public InheritanceMember( string name, Extensions extensions )
            : base( name ) {
            this.extensions_ = extensions;
        }

        /// <inheritdoc/>
        public InheritanceMember( string name )
            : this( name, Extensions.None ) { }


        /// <inheritdoc/>
        protected override void WriteCore( ICodeWriter writer ) {
            writer.Write( "    " + this.Name );
        }

    }

#>
<#+ // InitializationMember.cs

    /// <summary>
    /// Writes code for a member initialization.
    /// </summary>
    public sealed class InitializationMember : TypedMember {

        /// <summary>Scope for instance members.</summary>
        public const string InstanceMemberScope = "this";

        /// <summary>Scope for OnApplyTemplate members.</summary>
        public const string OnApplyTemplateMemberScope = "OnApplyTemplate";

        private readonly string value_;
        private readonly Action<ICodeWriter> valueWriter_;
        private readonly List<Guard> guards_ = new List<Guard>( );


        /// <inheritdoc/>
        public override bool InlineDoc { get { return false; } }

        /// <inheritdoc/>
        public override Extensions UsedExtensions {
            get {
                Extensions usedExtensions = this.ReferencedExtensions
                    | (this.DependentInitializer ?? Member.Empty).UsedExtensions;
                if( this.Guards.Any( ) )
                    usedExtensions |= Extensions.Validation;
                return usedExtensions;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether to write the "variable = " assignment statement.
        /// </summary>
        public bool WriteVariableAssignment { get; set; }

        /// <summary>
        /// Gets or sets the accessor scope for the member to initialize.
        /// </summary>
        /// <remarks>The default value is the <see cref="InstanceMemberScope"/>, <c>"this"</c>.</remarks>
        public string MemberScope { get; set; }

        /// <summary>
        /// Gets or sets an initializer that depends on the initialization of the current value.
        /// </summary>
        public InitializationMember DependentInitializer { get; set; }

        /// <summary>
        /// Gets or sets additional extensions referenced by the member being initialized.
        /// </summary>
        public Extensions ReferencedExtensions { get; set; }

        /// <summary>
        /// Gets the value to initialize the member with, or <null/> if the value is written manually.
        /// </summary>
        public string Value { get { return this.value_; } }

        /// <summary>
        /// Gets a value indicating whether <see cref="Value"/> is a constructor parameter or is a default value.
        /// </summary>
        public bool IsParameterValue { get { return this.Type.Length > 0; } }

        /// <summary>
        /// Gets a value indicating whether the member initializes an instance member.
        /// </summary>
        public bool IsInstance { get { return this.MemberScope == InstanceMemberScope; } }

        /// <summary>
        /// Gets a value indicating whether the member initializes an OnApplyTemplate member.
        /// </summary>
        public bool IsOnApplyTemplate { get { return this.MemberScope == OnApplyTemplateMemberScope; } }

        /// <summary>
        /// Gets the collections of guards for the member.
        /// </summary>
        public IEnumerable<Guard> Guards { get { return this.guards_.AsEnumerable( ); } }


        /// <summary>
        /// Initializes a new <see cref="InitializationMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the member to initialize.</param>
        /// <param name="value">The value to initialize the member with.</param>
        public InitializationMember( string name, string value )
            : this( name, "", false, value ) { }

        /// <summary>
        /// Initializes a new <see cref="InitializationMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the member to initialize.</param>
        /// <param name="parameterType">The type of the parameter used to initialize the member.</param>
        /// <param name="parameterName">The name of the parameter used to initialize the member.</param>
        public InitializationMember( string name, string parameterType, string parameterName )
            : this( name, parameterType, true, parameterName ) { }

        private InitializationMember( string name, string type, bool isTypeRequired, string value )
            : this( name, type, isTypeRequired, value, w => w.Write( value ) ) {
            Ensure.NotNullOrEmpty( value );
        }

        /// <summary>
        /// Initializes a new <see cref="InitializationMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the member to initialize.</param>
        /// <param name="valueWriter">A method to write the value to initialize the member with.</param>
        public InitializationMember( string name, Action<ICodeWriter> valueWriter )
            : this( name, "", false, null, valueWriter ) { }

        private InitializationMember( string name, string type, bool isTypeRequired, string value, Action<ICodeWriter> valueWriter )
            : base( name, type, isTypeRequired ) {
            Ensure.NotNull( valueWriter );

            this.value_ = value;
            this.valueWriter_ = valueWriter;

            this.WriteVariableAssignment = true;
            this.MemberScope = InstanceMemberScope;
        }


        /// <summary>
        /// Adds guards to the member.
        /// </summary>
        public InitializationMember AddGuards( IEnumerable<Guard> newGuards ) {
            this.guards_.AddRange( newGuards );
            return this;
        }


        /// <inheritdoc/>
        protected override void WriteCore( ICodeWriter writer ) {
            string scope = this.IsOnApplyTemplate ? InstanceMemberScope : this.MemberScope;
            if( this.WriteVariableAssignment )
                writer.Write( "{0}.{1} = ", scope, this.Name );
            this.valueWriter_( writer );
            writer.WriteLine( ";" );

            if( this.DependentInitializer != null )
                this.DependentInitializer.Write( writer );
        }

    }

#>
<#+ // IWritable.cs

    /// <summary>
    /// Represents an object that can be written.
    /// </summary>
    public interface IWritable {

        /// <summary>
        /// Writes the object to the specified <see cref="IFileWriter"/>.
        /// </summary>
        void Write( ICodeWriter writer );

    }

#>
<#+ // Member.cs

    /// <summary>
    /// Writes code for an implementation member.
    /// </summary>
    public abstract class Member : IWritable {

        public static readonly Member Empty = new EmptyMember( );

        private readonly string name_;

        private Doc doc_;


        /// <summary>
        /// Gets the name of the member.
        /// </summary>
        public string Name { get { return this.name_; } }

        /// <summary>
        /// Gets or sets the documentation for the member.
        /// </summary>
        public Doc Doc {
            get { return this.doc_; }
            set {
                if( !object.Equals( this.doc_, value ) ) {
                    this.doc_ = value;
                    this.OnDocChanged( );
                }
            }
        }

        /// <summary>
        /// Gets or sets the conditional compilation symbol for the member.
        /// </summary>
        public CompilationSymbol Condition { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether a new line should be inserted between the output of adjacent members.
        /// </summary>
        public bool SpaceOutput { get; set; }

        /// <summary>
        /// Gets a value indicating whether documentation should appear inline with the member, or manually written elsewhere.
        /// </summary>
        public virtual bool InlineDoc { get { return true; } }

        /// <summary>
        /// Gets a value indicating the extensions used by the member, such as <see cref="Guard"/>s,
        /// <see cref="System.Windows.Freezable"/> types, or dependency property validation.
        /// </summary>
        public abstract Extensions UsedExtensions { get; }


        /// <summary>
        /// Initializes a new <see cref="Member"/> instance.
        /// </summary>
        /// <param name="name">The name of the member.</param>
        protected Member( string name ) {
            Ensure.NotNullOrEmpty( name );
            this.name_ = name;
        }


        /// <summary>
        /// Assigns the value used for the <see cref="Condition"/> property.
        /// </summary>
        public Member SetCondition( CompilationSymbol condition ) {
            this.Condition = condition;
            return this;
        }


        /// <inheritdoc/>
        public void Write( ICodeWriter writer ) {
            Ensure.NotNull( writer );

            this.WriteDoc( writer );
            this.PreWrite( writer );
            this.WriteCore( writer );
            this.PostWrite( writer );
        }

        /// <inheritdoc cref="Write"/>
        protected abstract void WriteCore( ICodeWriter writer );

        /// <summary>Called before <see cref="PreWrite"/>.</summary>
        protected virtual void WriteDoc( ICodeWriter writer ) {
            if( this.InlineDoc && this.Doc != null )
                this.Doc.Write( writer );
        }

        /// <summary>Called before <see cref="WriteCore"/>.</summary>
        protected virtual void PreWrite( ICodeWriter writer ) { }

        /// <summary>Called after <see cref="WriteCore"/>.</summary>
        protected virtual void PostWrite( ICodeWriter writer ) { }

        /// <summary>
        /// Called whenever the <see cref="Member.Doc"/> property changes.
        /// </summary>
        protected virtual void OnDocChanged( ) { }


        /// <summary>
        /// Writes each member in the specified collection.
        /// </summary>
        public static void WriteMembers<T>( ICodeWriter writer, IEnumerable<T> members, Action<int, bool> separate )
            where T : Member {
            Ensure.NotNull( writer, members );

            // Order all top-level Members by type.
            var groupedMembers = members.GroupBy( m =>
                m is EmptyMember ? -1 :
                m is ConstantMember ? 0 :
                m is FieldMember ? 1 :
                m is AccessorMember ? 2 :
                m is MethodMember ? 3 :
                m is MemberGroup ? 4 :
                5
            )
            .Where( g => g.Key >= 0 )
            .OrderBy( g => g.Key )
            .ToArray( );

            // If all conditions are the same, combine members into a single group.
            var allGroups = groupedMembers.SelectMany( g => g );
            var allConditions = allGroups.Select( m => m.Condition ).ToArray( );
            var firstCondition = allConditions.FirstOrDefault( );
            if( !firstCondition.Equals( CompilationSymbol.None ) && allConditions.All( c => c.Equals( firstCondition ) ) ) {
                WriteConditionalMembers( writer, allGroups, separate, null );
            }
            // Write out each group of members, separated by newlines.
            else {
                Util.Iterate(
                    groupedMembers,
                    ( groupIndex, lastGroup ) => writer.WriteLine( ),
                    ( groupIndex, group ) => WriteConditionalMembers( writer, group, separate, null )
                );
            }
        }
        public static void WriteMembers<T>( ICodeWriter writer, IEnumerable<T> members ) where T : Member { WriteMembers( writer, members, null ); }

        /// <summary>
        /// Writes the <see cref="Member.Doc"/> for each member in the specified collection.
        /// </summary>
        public static void WriteMemberDocumentation<T>( ICodeWriter writer, IEnumerable<T> members )
            where T : Member {
            Ensure.NotNull( writer, members );

            var docs = members
                .Select( p => p.Doc )
                .Where( d => d != null );
            foreach( Doc doc in docs ) {
                doc.Write( writer );
            }
        }

        /// <summary>
        /// Writes each member in the specified collection, grouped by <see cref="Condition"/>.
        /// </summary>
        public static void WriteConditionalMembers<T>( ICodeWriter writer, IEnumerable<T> members, Action<int, bool> separate, Action<IGrouping<CompilationSymbol, T>[], int> customizeGroup )
            where T : Member {
            // Group by condition, distinguishing overriding and unconditional members.
            IGrouping<CompilationSymbol, T>[] conditionalMembers = members
                .OrderBy( member => member.Condition )
                .GroupBy( member => member.Condition )
                .ToArray( );
            if( conditionalMembers.Length == 0 )
                return;

            if( customizeGroup != null )
                customizeGroup( conditionalMembers, -1 );

            // Write each group of conditionals.
            bool anyUnconditionalMembers = conditionalMembers.Any( g => g.Key.IsUnconditional );
            for( int i = 0; i < conditionalMembers.Length; ++i ) {
                var conditionalGroup = conditionalMembers[i];
                var condition = conditionalGroup.Key;
                var previousCondition = i == 0 ? CompilationSymbol.None : conditionalMembers[i - 1].Key;
                var nextCondition = i + 1 == conditionalMembers.Length ? CompilationSymbol.None : conditionalMembers[i + 1].Key;

                // Get the preprocessor condition appropriate to the current group and symbol.
                string conditionFormat;
                if( condition.IsUnconditional )
                    conditionFormat = "";
                else if( previousCondition.Symbol == condition.Symbol )
                    conditionFormat = "#else";
                else
                    conditionFormat = "#if {0}{1}";

                // Write conditional group opening.
                bool hasCondition = !string.IsNullOrEmpty( conditionFormat );
                if( hasCondition )
                    writer.WriteLineUnindented( conditionFormat, condition.IsElseCondition ? "!" : "", condition.Symbol );
                if( customizeGroup != null )
                    customizeGroup( conditionalMembers, i );

                // Write conditional group members.
                Util.Iterate(
                    conditionalGroup,
                    ( memberIndex, lastMember ) => {
                        if( separate != null )
                            separate( memberIndex, lastMember );
                        if( conditionalGroup.ElementAt( memberIndex ).SpaceOutput )
                            writer.WriteLine( );
                    },
                    ( memberIndex, member ) => member.Write( writer )
                );

                // Write conditional group closing.
                bool last = (i + 1 == conditionalMembers.Length);
                if( anyUnconditionalMembers && !last && separate != null )
                    separate( -1, true );

                bool closeCondition = hasCondition && (last || nextCondition.Symbol != condition.Symbol);
                if( closeCondition ) {
                    writer.WriteUnindented( "#endif" );
                    if( customizeGroup == null )
                        writer.WriteLine( );
                }
            }
        }


        private sealed class EmptyMember : Member {
            public EmptyMember( ) : base( "<empty>" ) { }

            /// <inheritdoc/>
            public override Extensions UsedExtensions { get { return Extensions.None; } }

            /// <inheritdoc/>
            protected override void WriteCore( ICodeWriter writer ) { }
        }

    }

#>
<#+ // MemberGroup.cs

    /// <summary>
    /// Writes code for a group of members.
    /// </summary>
    public sealed class MemberGroup : Member {

        private readonly List<Member> members_ = new List<Member>( );


        /// <inheritdoc/>
        public override Extensions UsedExtensions {
            get { return Util.GetUsedExtensions( this.Members ); }
        }

        /// <summary>
        /// Gets the list of <see cref="Member"/> objects in the group.
        /// </summary>
        public IList<Member> Members { get { return this.members_; } }


        /// <summary>
        /// Initializes a new <see cref="MemberGroup"/> instance.
        /// </summary>
        /// <param name="name">The name of the group.</param>
        public MemberGroup( string name )
            : base( name ) { }


        /// <inheritdoc/>
        protected override void WriteCore( ICodeWriter writer ) {
            Ensure.Satisfies( !this.Members.OfType<InitializationMember>( ).Any( ), "Cannot write initializers in nested group." );

            using( Enclose.Region( writer, this.Name ) ) {
                WriteMembers( writer, this.Members );
            }
        }

    }

#>
<#+ // MethodMember.cs

    /// <summary>
    /// Writes code for a method declaration.
    /// </summary>
    public sealed class MethodMember : HelpedMember {

        private readonly List<ParameterMember> parameters_ = new List<ParameterMember>( );
        private readonly List<Doc> docDependencies_ = new List<Doc>( );
        private readonly BlockMember body_;


        /// <inheritdoc/>
        public override Extensions UsedExtensions {
            get {
                return base.UsedExtensions
                     | (this.Body ?? Member.Empty).UsedExtensions
                     | Util.GetUsedExtensions( this.Parameters );
            }
        }

        /// <summary>
        /// Gets a value indicating whether this is a partial method.
        /// </summary>
        public bool IsPartialMethod { get { return this.Body == null; } }

        /// <summary>
        /// Gets the list of parameters for the method.
        /// </summary>
        public IList<ParameterMember> Parameters { get { return this.parameters_; } }

        /// <summary>
        /// Gets the list of additional Doc values to apply as setting dependencies.
        /// </summary>
        public IList<Doc> DocDependencies { get { return this.docDependencies_; } }

        /// <summary>
        /// Gets the body of the method, or <null/> if it is a partial method.
        /// </summary>
        public BlockMember Body { get { return this.body_; } }


        /// <summary>
        /// Initializes a new <see cref="MethodMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the method.</param>
        /// <param name="returnType">The return type of the method.</param>
        /// <param name="body">The body of the method.</param>
        public MethodMember( string name, string returnType, BlockMember body )
            : base( name, returnType, !IsConstructor( body ), "public" ) {
            this.body_ = body;

            this.SpaceOutput = true;
        }


        /// <summary>
        /// Adds the specified parameters to the <see cref="Parameters"/> list.
        /// </summary>
        public MethodMember AddParameters( IEnumerable<ParameterMember> parameters ) {
            this.parameters_.AddRange( parameters );
            return this;
        }

        /// <summary>
        /// Constructs and adds <see cref="ParameterMember"/>s based on the parameters of the existing method.
        /// </summary>
        public static IEnumerable<ParameterMember> GetParameters( MethodBase existingMethod, Func<string, Type, string, ParameterMember> createParameter ) {
            Ensure.NotNull( existingMethod, createParameter );

            var existingParameters = existingMethod.GetParameters( );
            var parameterDocs = existingParameters.Select( p => p.Name ).ToDictionary( n => n, n => "" );

            try {
                var methodDoc = XmlDocumentation.GetDocMember( existingMethod );
                parameterDocs = methodDoc.Elements( "param" ).ToDictionary(
                    paramDoc => paramDoc.Attribute( "name" ).Value,
                    paramdDoc => XmlDocumentation.GetElementValue( paramdDoc )
                );
            }
            catch( Exception e ) {
                string errorMessage = string.Format( "Could not get documentation for existing method {0}:{1}{2}", existingMethod, Environment.NewLine, e );
                System.Diagnostics.Debug.WriteLine( errorMessage );
            }

            foreach( var parameter in existingParameters ) {
                string name = parameter.Name;
                yield return createParameter( name, parameter.ParameterType, parameterDocs[name] );
            }
        }


        /// <inheritdoc/>
        protected override void WriteDoc( ICodeWriter writer ) {
            if( this.Doc != null ) {
                this.Doc.UpdateSettings( this.Parameters.Select( p => p.Doc ) );
                this.Doc.UpdateSettings( this.DocDependencies );
            }

            base.WriteDoc( writer );
            if( !this.IsPartialMethod )
                Member.WriteMemberDocumentation( writer, this.Parameters );
        }

        /// <inheritdoc/>
        protected override void WriteCore( ICodeWriter writer ) {
            string type = this.Type + (this.Type.Length > 0 ? " " : "");
            string modifiers = this.IsPartialMethod
                ? (this.Modifiers.Contains( "static" ) ? "static " : "") + "partial"
                : this.Modifiers;
            writer.Write( "{0} {1}{2}", modifiers, type, this.Name );

            using( Enclose.Parenthesis( writer ) ) {
                WriteMembers( writer, this.Parameters, ( i, last ) => writer.Write( ", " ) );
            }

            if( this.IsPartialMethod ) {
                writer.WriteLine( ";" );
            }
            else {
                writer.WriteLine( );
                this.Body.Write( writer );
            }
        }

        /// <inheritdoc/>
        protected override void OnDocChanged( ) {
            base.OnDocChanged( );

            if( this.Doc != null )
                this.Doc.AddExceptions( this.Body.Guards );
        }


        private static bool IsConstructor( BlockMember body ) {
            string bodyName = body != null
                ? body.Name.Trim( )
                : null;
            return bodyName != null
                && (bodyName[0] == '.' || bodyName[0] == ':');
        }

    }

#>
<#+ // ModifiedTypedMember.cs

    /// <summary>
    /// Writes code for a member with a type and modifiers.
    /// </summary>
    public abstract class ModifiedTypedMember : TypedMember {

        private readonly List<AttributeMember> attributes_ = new List<AttributeMember>( );


        /// <summary>
        /// Gets or sets field modifiers (i.e. "public", "static").
        /// </summary>
        public string Modifiers { get; set; }

        /// <summary>
        /// Gets the collection of attribute members used by the accessor.
        /// </summary>
        public IList<AttributeMember> Attributes { get { return this.attributes_; } }


        /// <summary>
        /// Initializes a new <see cref="ModifiedTypedMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the member.</param>
        /// <param name="type">The type of the member.</param>
        /// <param name="modifiers">The modifiers on the member.</param>
        protected ModifiedTypedMember( string name, string type, string modifiers )
            : this( name, type, true, modifiers ) { }

        /// <summary>
        /// Initializes a new <see cref="ModifiedTypedMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the member.</param>
        /// <param name="type">The type of the member.</param>
        /// <param name="isTypeRequired">Indicates whether <paramref name="type"/> must be set.</param>
        /// <param name="modifiers">The modifiers on the member.</param>
        protected ModifiedTypedMember( string name, string type, bool isTypeRequired, string modifiers )
            : base( name, type, isTypeRequired ) {
            this.Modifiers = modifiers ?? "";
        }


        /// <summary>
        /// Adds the specified attributes to the <see cref="Attributes"/> collection.
        /// </summary>
        public void AddAttributes( IEnumerable<AttributeMember> attributes ) {
            this.attributes_.AddRange( attributes );
        }

        /// <inheritdoc/>
        protected override void PreWrite( ICodeWriter writer ) {
            base.PreWrite( writer );
            if( this.Attributes.Any( ) )
                WriteMembers( writer, this.Attributes );
        }

    }

#>
<#+ // ParameterMember.cs

    /// <summary>
    /// Writes code for a parameter declaration.
    /// </summary>
    public sealed class ParameterMember : TypedMember {

        /// <inheritdoc/>
        public override bool InlineDoc { get { return false; } }

        /// <inheritdoc/>
        public override Extensions UsedExtensions { get { return Extensions.None; } }


        /// <summary>
        /// Initializes a new <see cref="ParameterMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the parameter.</param>
        /// <param name="type">The type of the parameter.</param>
        public ParameterMember( string name, string type )
            : base( name, type, true ) {
        }


        /// <inheritdoc/>
        protected override void WriteCore( ICodeWriter writer ) {
            writer.Write( "{0} {1}", this.Type, this.Name );
        }

    }

#>
<#+ // TypedMember.cs

    /// <summary>
    /// Writes code for a member with a type.
    /// </summary>
    public abstract class TypedMember : Member {

        private readonly string type_;


        /// <summary>
        /// Gets the type of the member.
        /// </summary>
        public string Type { get { return this.type_; } }


        /// <summary>
        /// Initializes a new <see cref="TypedMember"/> instance.
        /// </summary>
        /// <param name="name">The name of the member.</param>
        /// <param name="type">The type of the member.</param>
        /// <param name="isTypeRequired">Indicates whether or not <paramref name="type"/> is required.</param>
        protected TypedMember( string name, string type, bool isTypeRequired )
            : base( name ) {
            if( isTypeRequired )
                Ensure.NotNullOrEmpty( type );

            this.type_ = type ?? "";
        }

    }

#>
